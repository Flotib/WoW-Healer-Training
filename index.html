<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>WoW Healer Training</title>
    <link rel="icon" href="img/pageicon.png" />
    <link rel="stylesheet" href="css/styles.css">
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.js"></script>
</head>

<body>
    <div id="app">
        <button @click="addAlly">debugspawn</button>
        <button @click="addSpell">debugaddspell</button>
        <button @click="playerSetMinMana">mana 0</button>
        <button @click="playerSetMaxMana">mana 100</button>
        <button @click="player.addMana(-10)">Mana -10</button>
        <!--<input v-model="manaRegen" id="number" type="number" style="width: 35px;">-->
        <input v-model="player.haste" type="number" style="width: 50px; color: #2c1f3d" @input="hasteCalculation">
        <div style="color: white; display: inline-block;">
            {{ selectedEntity ? selectedEntity.id : 'none' }}
            <div style="color: #b3b3b3; display: inline-block; margin-left: 10px;">
                {{ selected ? selected : 'none' }}
            </div>
            <div style="color: #e44f4f; display: inline-block; margin-left: 10px;">
                {{ isPlayerCasting }}
            </div>
            <div style="color: #e4f079; display: inline-block; margin-left: 10px;">
                {{ isPlayerChanneling }}
            </div>
            <div style="color: #b3b3b3; display: inline-block; margin-left: 10px;">
                {{ keyPressed }}
            </div>
            <div style="color: #b3b3b3; display: inline-block; margin-left: 10px;">
                {{ hover }}
            </div>
            <div style="color: #8ecbee; display: inline-block; margin-left: 10px;">
                {{ holdClickHover }}
            </div>
            <div style="color: #5656ff; display: inline-block; margin-left: 10px;">
                {{ Number((player.mana).toFixed(2)) }}
            </div>
            <div style="color: #56ff5e; display: inline-block; margin-left: 10px;">
                {{ Number((player.hp).toFixed(2)) }}
            </div>
            <div style="color: #ae7eec; display: inline-block; margin-left: 10px;">
                {{ player.haste }}
            </div>
            <div style="color: #ffffff; display: inline-block; margin-left: 10px;">
                {{ Number(globalCooldown.toFixed(2)) }}
            </div>
        </div>

        <div class="flexframe">
            <div class="allyframecontainer">
                <div v-for="(ally,index) in allies" :key="index" :class="'allyhpbar' +(selected==index?' selected':'')"
                    :data-label="formatHpLabel(ally)" @click="()=>selected=index">
                    <span class="allyhpvalue" :style="'width:'+Math.max(0,ally.hp)+'%'"></span>
                    <span v-if="ally.hpShield > 0" class="shieldBar"
                        :style="'width:'+Math.max(0,ally.hpShield)+'%'"></span>
                    <span class="role"><img :src="'img/roles/'+ally.role+'.png'" /></span>
                </div>
            </div>
        </div>

        <div class="playerInterface">

            <div :class="'playerFrame' +(selected==player.id?' selected':'')" @click="()=>selected=player.id">
                <div class="playerHPbar" :data-label="Number((player.hp).toFixed(1))+'%'">
                    <span class="playerHPbarContent" :style="'width:'+player.hp+'%'"></span>
                </div>
                <div class="playerManabar" :data-label="Number((player.mana).toFixed(1))+'%'">
                    <span class="playerManabarContent" :style="'width:'+player.mana+'%'"></span>
                </div>
            </div>

            <div class="pcastbar" :data-label="currentCastLabel">
                <div class="castbarbg" :style="'width:'+castbarBackground+'%'"></div>
                <div v-if="isPlayerCasting || isPlayerChanneling" class="castBarGlowing"
                    :style="'left:'+spellProgressBar+'%'"></div>
                <div v-if="isPlayerCasting && incantTotalTime>=400" class="spellQueueIndicator"
                    :style="'left:'+((incantTotalTime-spellQueueDelay)/incantTotalTime*100)+'%'"></div>
                <div v-if="isPlayerChanneling" class="channelTicksIndicator" v-for="i in spellchannelTicks"
                    :style="'right:'+(100/spellchannelTicks*i)+'%'"></div>
                <div :class="{ pincantationtime:isPlayerCasting, pincantationtimeChanneling:isPlayerChanneling }"
                    :style="'width:'+spellProgressBar+'%'"></div>
            </div>

            <div class="spellbar">
                <!-- Idk if the behaviour is correct but when you press the click on a spell and then release it on another spell, the spell isn't cast => @click. -->
                <div v-for="(spell,index) in spells" :key="index" class="spellcontainer" @click="()=>useSpell(spell)"
                    @mouseover="() => onSpellHover(spell)" @mouseleave="() => onSpellLeave(spell)"
                    @mousedown="holdClickHoverOn" @mouseup="holdClickHoverOff" @touchstart="holdClickHoverOn"
                    @touchend="holdClickHoverOff" @touchcancel="holdClickHoverOff">
                    <img v-if="spell.icon" :src="'img/spells/'+spell.icon+'.jpg'" />
                    <div v-if="spell.icon && (spell.mana>player.mana || spell.manapersecond>player.mana)"
                        class="notEnoughManaSpell"></div>
                    <div :class="{spellHover:!holdClickHover}"></div>
                    <div :class="{spellHoverClickHold:holdClickHover}"></div>
                    <div v-if="spell.currentCooldown != 0" class="spellCooldownBackground"
                        :style="'background: conic-gradient(transparent '+(360*(1-spell.currentCooldown/spell.cooldown))+'deg, #14161bb0 '+(360*(1-spell.currentCooldown/spell.cooldown))+'deg);'">
                    </div>
                    <div v-if="spell.currentCooldown == 0 && underGCD" class="spellCooldownBackground"
                        :style="'background: conic-gradient(transparent '+(360*(1-remainGCD/globalCooldown))+'deg, #14161bb0 '+(360*(1-remainGCD/globalCooldown))+'deg);'">
                    </div>
                    <div v-if="spell.currentCooldown != 0 && spell.currentCooldown>60000" class="spellCooldownTimer"
                        style="font-size: 20px;">{{ Math.ceil(spell.currentCooldown/1000/60) }} m</div>
                    <div v-if="spell.currentCooldown != 0 && spell.currentCooldown<=60000" class="spellCooldownTimer"
                        style="font-size: 25px;">{{ Math.ceil(spell.currentCooldown/1000) }}</div>
                </div>
            </div>

            <div class="spellTooltipPosition" v-if="hover">
                <div class="spellTooltipTitle">
                    {{ hoveredSpell.name }}
                </div>
                <div class="spellTooltipManaCost" v-if="hoveredSpell.mana>0 && !hoveredSpell.channeled">
                    {{ hoveredSpell.mana }}% Mana
                </div>
                <div class="spellTooltipManaCost" v-if="hoveredSpell.manapersecond>0 && hoveredSpell.channeled">
                    {{ hoveredSpell.manapersecond }}% Mana per second
                </div>
                <div class="spellTooltipCastTime">
                    <template v-if="hoveredSpell.incantTime>1">{{ Number((hoveredSpell.incantTime/1000).toFixed(2)) }}
                        sec cast</template>
                    <template v-else-if="hoveredSpell.incantTime==0 && !hoveredSpell.channeled">Instant</template>
                    <template v-else-if="hoveredSpell.channeled">Channeled</template>
                    <div class="spellTooltipCooldown" v-if="hoveredSpell.cooldown>0">
                        {{ Number((hoveredSpell.cooldown/1000/60).toFixed(1)) }} min cooldown
                    </div>
                </div>
                <div class="spellTooltipDesc">
                    {{ hoveredSpell.tooltip.replace('#channeltime', Number((hoveredSpell.channelTime/1000).toFixed(2)))
                    }}
                </div>
            </div>
        </div>
    </div>

    <script>
        function rand(min, max) { // min and max included 
            return Math.floor(Math.random() * (max - min + 1) + min);
        }
        var app = new Vue({
            el: '#app',
            data: {
                keyPressed: false,
                globalIncrement: 0,
                selected: -1,
                currentCast: -1,
                currentCastAnim: -1,
                currentCastName: null,
                currentCastTime: null,
                spellProgressBar: 0,
                castbarBackground: 0,
                incantTotalTime: 0,
                breakIncantation: 0,
                breakChanneling: 0,
                castTimeRemaining: 0,
                channelTicksInterval: null,
                isPlayerCasting: false,
                isPlayerChanneling: false,
                hover: false,
                hoveredSpell: null,
                holdClickHover: false,
                spellInQueue: false,
                manaRegen: 0.25,
                globalCooldown: 1500,
                remainGCD: null,
                underGCD: false,
                spellQueueDelay: 400,
                spellchannelTicks: 0,
                allies: [
                ],
                player: {
                    hp: 10,
                    hpShield: 0,
                    mana: 100,
                    id: -1,
                    spellPower: 100,
                    haste: 0,
                    addMana: function (value) {
                        this.mana = Math.max(0, Math.min(100, this.mana + value))
                    },
                    addHp: function (value) {
                        if (this.hpShield > 0 && value < 0) { // If the target have a shield and lose HP
                            if (this.hpShield + value < 0) {
                                value = value + this.hpShield
                                this.hpShield = 0
                                this.hp = Math.max(0, Math.min(100, this.hp + value))
                            } else if (this.hpShield + value >= 0) {
                                this.hpShield = Math.max(0, Math.min(100, this.hpShield + value))
                            }
                        } else { // If the target don't have shield and lose HP or have shield but get HP
                            this.hp = Math.max(0, Math.min(100, this.hp + value))
                        }
                    },
                    addShield: function (value) {
                        this.hpShield = Math.max(0, Math.min(100, this.hpShield + value))
                    },
                    setShield: function (value) { // set shield, because shield are not stackables if they come from the same spell /!\ need to add buff for that sh*t

                    },
                },
                spells: [
                ],
                spellPool: {
                    Priest: [ // Name of the class which have the following spells (for the moment there is only one class because the game isn't achieved yet, obviously)
                        {
                            name: "Flash Heal", // Name of the spell
                            mana: 3.6, // Mana used by the spell
                            manapersecond: 0,  // Mana per second use by the spell, used only by channeled spells
                            tooltip: "A fast spell that heals an ally for", // (203% of Spell power).",  // Tooltip of the spell which appear when the spell is hover
                            icon: "spell_holy_flashheal", // Icon of the spell
                            baseIncantTime: 1500, // Base spell incant time, this value never change and is used by some functions
                            incantTime: 1500, // Actual incant time, by default it have the same value as the base one but it change depending of the player haste
                            baseChannelTime: 0, // Same as baseIncantTime but for channeled spells
                            channelTime: 0, // Channeling time
                            channelTicks: 0, // How many time between every ticks in channeling to trigger the effect
                            channeled: false, // false : the spell is a normal one (castable), true : the spell is a channeled one
                            cooldown: 0, // The cooldown applied after the cast of the spell
                            currentCooldown: 0, // Current cooldown, this value change if the spell have a cooldown, after it've been used
                            affectGCD: true, // If using this spell affect the GCD
                            deadTargetEffect: 0, // 0 = false; 1 = true ==> if the spell is only usable on dead allies (only for battle rez, i think c:)
                            key: 49, // Keybinding, should change in several updates, when I'll added the key on the spellbar, not on the spell itself
                            use: (game, state) => { // Function of the spell when it is used
                                game.findEntityById(state.selectedEntityId).addHp(15) // Here, the spell adds hp to the target
                            },
                        },
                        {
                            name: "Heal",
                            mana: 2.4,
                            manapersecond: 0,
                            tooltip: "An efficient spell that heals an ally for", // (295% of Spell power).",
                            icon: "spell_holy_greaterheal",
                            baseIncantTime: 2500,
                            incantTime: 2500,
                            baseChannelTime: 0,
                            channelTime: 0,
                            channelTicks: 0,
                            channeled: false,
                            cooldown: 0,
                            currentCooldown: 0,
                            affectGCD: true,
                            deadTargetEffect: 0,
                            key: 50,
                            use: (game, state) => {
                                game.findEntityById(state.selectedEntityId).addHp(30)
                            },
                        },
                        {
                            name: "Rebirth",
                            mana: 0,
                            manapersecond: 0,
                            tooltip: "Returns the spirit to the body, restoring a dead target to life with 100% health. Castable in combat.",
                            icon: "spell_nature_reincarnation",
                            baseIncantTime: 2000,
                            incantTime: 2000,
                            baseChannelTime: 0,
                            channelTime: 0,
                            channelTicks: 0,
                            channeled: false,
                            cooldown: 600000,
                            currentCooldown: 0,
                            affectGCD: true,
                            deadTargetEffect: 1,
                            key: 51,
                            use: (game, state) => {
                                game.findEntityById(state.selectedEntityId).addHp(100)
                            },
                        },
                        {
                            name: "Soothing Mist",
                            mana: 0,
                            manapersecond: 0.4,
                            tooltip: "Heals the target for (440% of Spell power) over #channeltime sec.  While channeling, Enveloping Mist and Vivify may be cast instantly on the target.",
                            icon: "ability_monk_soothingmists",
                            baseIncantTime: 0,
                            incantTime: 0,
                            baseChannelTime: 8000,
                            channelTime: 8000,
                            channelTicks: 8,
                            channeled: true,
                            cooldown: 0,
                            currentCooldown: 0,
                            affectGCD: true,
                            deadTargetEffect: 0,
                            key: 52,
                            use: (game, state) => {
                                game.findEntityById(state.selectedEntityId).addHp(5)
                            },
                        },
                        {
                            name: "Power Word: Shield",
                            mana: 3.1,
                            manapersecond: 0,
                            tooltip: "Shields an ally for 15 sec, absorbing [Spell power * 1.65 * (1 + Versatility) * 1 * 1] damage.  You cannot shield the target again for 7.5 sec.",
                            icon: "spell_holy_powerwordshield",
                            baseIncantTime: 0,
                            incantTime: 0,
                            baseChannelTime: 0,
                            channelTime: 0,
                            channelTicks: 0,
                            channeled: false,
                            cooldown: 0,
                            currentCooldown: 0,
                            affectGCD: true,
                            deadTargetEffect: 0,
                            key: 53,
                            effect: 1, // good way to do this sh*t --> get buff by id and add buff to target when you ended cast the spell cast. The shield must be on the buff, not the entity :/
                            use: (game, state) => {
                                game.findEntityById(state.selectedEntityId).addShield(5) // need to change that later
                            },
                        },
                    ],
                },
                effects: [ // not final, still thinking about how I can do this simply without reworking all my code
                    {
                        id: 1,
                        name: "test",
                        buff: true,
                        debuff: false,
                        effect: null,
                        effectTwo: null,
                        duration: 15000,
                        ticks: null, // time between every effect if the effect trigger something multiple times
                        tooltip: "test",
                        icon: null,
                    },
                ],
            },

            computed: {
                selectedEntity() {
                    if (this.selected == this.player.id) {
                        return this.player;
                    } else {
                        return this.allies[this.selected];
                    }
                },

                currentCastLabel() {
                    if (this.currentCast != -1) {
                        return this.currentCastName //+ " " + this.currentCastTime;
                    }
                },

            },

            methods: {
                onSpellHover(spell) {
                    if (!spell.name) {
                        return;
                    }

                    this.hover = true;
                    this.hoveredSpell = spell;
                },

                onSpellLeave(spell) {
                    if (this.hoveredSpell?.name == spell.name) {
                        this.hover = false;
                        this.hoveredSpell = null;
                        this.holdClickHover = false;
                    }
                },

                holdClickHoverOn() {
                    if (this.hoveredSpell) {
                        this.holdClickHover = true
                    }
                },

                holdClickHoverOff() {
                    this.holdClickHover = false
                },

                breakUseSpell() {
                    clearTimeout(this.currentCast)
                    this.currentCastAnim = -1
                    this.currentCast = -1
                    this.spellProgressBar = 0
                    this.castbarBackground = 0
                    this.currentCastName = null
                    this.isPlayerCasting = false
                    this.isPlayerChanneling = false
                    this.castTimeRemaining = 0
                },

                breakSpellAnimation() { // less instable than breakUseSpell
                    clearTimeout(this.currentCast)
                    this.currentCastAnim = -1
                    this.castbarBackground = 0
                    this.castTimeRemaining = 0
                    this.spellProgressBar = 0
                },

                addAlly() {
                    this.allies.push({
                        hp: Math.random() * 100,
                        hpShield: 0,
                        role: ["tank", "healer", "dps"][rand(0, 2)],
                        id: ++this.globalIncrement,
                        addHp: function (value) {
                            if (this.hpShield > 0 && value < 0) { // If the target have a shield and lose HP
                                if (this.hpShield + value < 0) {
                                    value = value + this.hpShield
                                    this.hpShield = 0
                                    this.hp = Math.max(0, Math.min(100, this.hp + value))
                                } else if (this.hpShield + value >= 0) {
                                    this.hpShield = Math.max(0, Math.min(100, this.hpShield + value))
                                }
                            } else { // If the target don't have shield and lose HP or have shield but get HP
                                this.hp = Math.max(0, Math.min(100, this.hp + value))
                            }
                        },
                        addShield: function (value) {
                            this.hpShield = Math.max(0, Math.min(100, this.hpShield + value))
                        },
                        setShield: function (value) { // same as player

                        },
                    })
                },

                cooldownSubstract(spell) {
                    setTimeout(() => {
                        spell.currentCooldown -= 1000 / 20
                        if (spell.currentCooldown > 0) {
                            this.cooldownSubstract(spell)
                        }
                    }, 1000 / 20)
                },

                globalCooldownFunction() {
                    this.underGCD = true
                    this.remainGCD = this.globalCooldown
                    const darkmoon = () => {
                        this.remainGCD -= 1000 / 60
                        if (Math.round(this.remainGCD) > 0) {
                            setTimeout(darkmoon, 1000 / 60);
                        } else {
                            this.remainGCD = null
                            this.underGCD = false
                        }
                    }
                    setTimeout(darkmoon, 1000 / 60);
                },

                findEntityById(id) {
                    if (id == this.player.id) {
                        return this.player
                    } else {
                        for (const ally of this.allies) {
                            if (ally.id == id) {
                                return ally;
                            }
                        }

                        return null;
                    }
                },

                formatHpLabel(ally) {
                    if (ally.hp <= 0) {
                        return "dead"
                    }

                    return Math.ceil(ally.hp) + '%'
                },

                formatHpShieldTabel(ally) {

                },

                addSpell() {
                    this.spells.push({})
                },

                playerSetMaxMana() {
                    this.player.mana = 100
                },

                playerSetMinMana() {
                    this.player.mana = 0
                },

                hasteCalculation() {
                    console.log(this.player.haste)
                    for (const spell of this.spells) {
                        spell.incantTime = spell.baseIncantTime / (1 + this.player.haste / 100)
                        spell.channelTime = spell.baseChannelTime / (1 + this.player.haste / 100)
                        this.globalCooldown = 1500 / (1 + this.player.haste / 100) // 1500 for baseGCD, if it cause problems later ==> create a var baseGCD in data
                    }
                },

                selectClass(clazz) {
                    this.spells.length = 0;

                    for (const spell of this.spellPool[clazz]) {
                        this.spells.push({
                            ...spell,
                        });
                    }

                    const totalspells = 24 - this.spells.length
                    for (let i = 0; i < totalspells; i++) {
                        this.addSpell()
                    }
                },

                useSpell(spell) {
                    if (spell.currentCooldown <= 0 && this.player.mana - spell.mana >= 0 && this.player.mana - spell.manapersecond >= 0) {
                        if (!spell.channeled) {
                            /*if (spell.incantTime <= 1000) {  // change the spellQueue delay if the spell incant time is lower than 1sec
                                this.spellQueueDelay = spell.incantTime * 0.5
                            }*/
                            this.breakIncantation = 0
                            this.breakChanneling = 0
                            if (this.isPlayerCasting && this.castTimeRemaining > this.spellQueueDelay) { // If it's a different spell, cancel the one currently being cast and cast the new one
                                //this.breakIncantation = 1
                                //this.breakUseSpell()
                                return

                            } else if (this.isPlayerCasting && this.castTimeRemaining <= this.spellQueueDelay && !this.spellInQueue) { // ADD TO QUEUE (chain spell)
                                if (!this.underGCD) {
                                    this.spellInQueue = true
                                    setTimeout(() => {
                                        this.spellInQueue = false
                                        this.useSpell(spell)
                                    }, this.castTimeRemaining)
                                    return
                                } else if (this.underGCD && this.castTimeRemaining <= this.remainGCD + 25) {
                                    this.spellInQueue = true
                                    setTimeout(() => {
                                        this.spellInQueue = false
                                        this.useSpell(spell)
                                    }, this.remainGCD + 25)
                                    return
                                } else { return }
                            }
                            if (!this.underGCD) { // verify if there is the GCD
                                if (this.isPlayerChanneling) { //toDo : when Soothing Mist is channeled the monk can use some spells instantly
                                    this.breakChanneling = 1
                                    this.isPlayerChanneling = false
                                    this.castTimeRemaining = 0
                                }
                                if (this.spellInQueue) { return }
                                if (spell.incantTime > 0) {
                                    this.currentCastName = spell.name
                                }
                                const selectedEntityId = this.selectedEntity.id
                                if (spell.deadTargetEffect == 0) { // Verify if the spell is a healing spell or a battle rez one and then verify if the target can be heal / rez
                                    if (this.findEntityById(selectedEntityId).hp <= 0) { // healing spell (break if target is dead)
                                        this.breakUseSpell()
                                        return
                                    }
                                } else {
                                    if (this.findEntityById(selectedEntityId).hp > 0) { // brez (break if target is alive)
                                        this.breakUseSpell()
                                        return
                                    }
                                }
                                if (spell.affectGCD) {
                                    this.globalCooldownFunction()
                                }
                                this.currentCast = 1
                                this.incantTotalTime = spell.incantTime;
                                let remain = spell.incantTime;
                                let whle = () => {
                                    if (this.breakIncantation == 1) { //break casting
                                        this.breakIncantation = 0
                                        this.breakSpellAnimation()
                                        return
                                    } else if (this.breakIncantation == 2) { //escape key
                                        this.breakIncantation = 0
                                        this.breakUseSpell()
                                        return
                                    }
                                    remain -= 1000 / 60
                                    this.castTimeRemaining = remain
                                    this.isPlayerCasting = true
                                    this.castbarBackground = 100
                                    this.currentCastTime = (remain / 1000 / 60)
                                    this.spellProgressBar = 100 - remain / spell.incantTime * 100
                                    if (this.player.mana - spell.mana < 0) {
                                        this.breakUseSpell()
                                        return
                                    }
                                    if (spell.deadTargetEffect == 0) {
                                        if (this.findEntityById(selectedEntityId).hp <= 0) {
                                            this.breakUseSpell()
                                            return
                                        }
                                    } /*else if (this.findEntityById(selectedEntityId).hp > 0) {
                                     this.breakUseSpell()
                                     return
                                    } This part is broken, and a lil' bit useless*/

                                    if (Math.round(remain) > 0) {
                                        this.currentCastAnim = setTimeout(whle, 1000 / 60);
                                    } else {
                                        spell.use(this, { selectedEntityId })
                                        spell.currentCooldown = spell.cooldown
                                        this.player.addMana(-spell.mana)
                                        this.currentCastAnim = -1
                                        this.currentCast = -1
                                        this.spellProgressBar = 0
                                        this.castbarBackground = 0
                                        this.currentCastName = null
                                        this.isPlayerCasting = false
                                        this.castTimeRemaining = 0
                                        if (spell.cooldown > 0) {
                                            this.cooldownSubstract(spell)
                                        }
                                        return
                                    }
                                }
                                this.currentCastAnim = setTimeout(whle, 1000 / 60);
                            }
                        }


                        else { // spell is channeled
                            this.breakIncantation = 0
                            this.breakChanneling = 0
                            if (!this.underGCD) {
                                if (spell.name == this.currentCastName) {
                                    this.breakChanneling = 1
                                }
                                if (this.isPlayerCasting) { return }
                                this.currentCastName = spell.name
                                const selectedEntityId = this.selectedEntity.id
                                if (spell.deadTargetEffect == 0) { // verify if target is dead
                                    if (this.findEntityById(selectedEntityId).hp <= 0) { // healing spell (break if target is dead)
                                        this.breakUseSpell()
                                        return
                                    }
                                }
                                if (spell.affectGCD) {
                                    this.globalCooldownFunction()
                                }
                                this.currentCast = 1
                                this.incantChannelTime = spell.channelTime;
                                this.channelTicksInterval = spell.channelTime / spell.channelTicks // channeled ticks interval's now here
                                let remain = spell.channelTime;
                                let ticks = this.channelTicksInterval
                                let whle = () => {
                                    if (this.breakChanneling == 1) { //break casting
                                        this.breakChanneling = 0
                                        this.breakSpellAnimation()
                                        return
                                    } else if (this.breakChanneling == 2) { //escape key
                                        this.breakChanneling = 0
                                        this.breakUseSpell()
                                        return
                                    }
                                    remain -= 1000 / 60
                                    ticks -= 1000 / 60
                                    this.castTimeRemaining = remain
                                    this.spellchannelTicks = spell.channelTicks
                                    this.isPlayerChanneling = true
                                    this.castbarBackground = 100
                                    this.currentCastTime = (remain / 1000 / 60)
                                    this.spellProgressBar = remain / spell.channelTime * 100
                                    if (this.player.mana - spell.manapersecond < 0) {
                                        this.breakUseSpell()
                                        return
                                    }
                                    if (spell.deadTargetEffect == 0) {
                                        if (this.findEntityById(selectedEntityId).hp <= 0) {
                                            this.breakUseSpell()
                                            return
                                        }
                                    }
                                    if (Math.round(ticks) <= 0) { // round to avoid a value like 8.0e-13 =)
                                        spell.use(this, { selectedEntityId })
                                        this.player.addMana(-spell.manapersecond)
                                        ticks = this.channelTicksInterval - 1000 / 60
                                    }
                                    if (Math.round(remain) > 0) {
                                        this.currentCastAnim = setTimeout(whle, 1000 / 60);
                                    } else {
                                        spell.currentCooldown = spell.cooldown
                                        this.currentCastAnim = -1
                                        this.currentCast = -1
                                        this.spellProgressBar = 0
                                        this.castbarBackground = 0
                                        this.currentCastName = null
                                        this.isPlayerChanneling = false
                                        this.castTimeRemaining = 0
                                        if (spell.cooldown > 0) {
                                            this.cooldownSubstract(spell)
                                        }
                                        return
                                    }
                                }
                                this.currentCastAnim = setTimeout(whle, 1000 / 60);
                            }
                        }
                    }
                },
            },

            mounted() {

                document.addEventListener("keydown", (event) => { // Detect if the pressed key is used by a spell, and if so, cast this spell
                    if (this.keyPressed) return;
                    this.keyPressed = true;
                    for (const spell of this.spells) {
                        if (spell.key == event.keyCode) {
                            this.useSpell(spell)
                            break
                        }
                    }


                    if (event.keyCode == 27) { // esc key role --> break cast and if not casting target player
                        if (this.castTimeRemaining > 0) {
                            this.breakIncantation = 2
                            this.breakChanneling = 2
                        } else {
                            this.selected = -1
                        }
                    }
                }, false);

                document.addEventListener("keyup", (event) => {
                    this.keyPressed = false;
                }, false);

                this.selectClass("Priest");

                for (let i = 0; i < 10; i++) {
                    this.addAlly();
                }

                let step = 0;

                setInterval(() => {
                    if (step % 45 == 0) {
                        for (const ally of this.allies) {
                            ally.addHp(-1)
                        }
                        this.player.addMana(this.manaRegen)
                    }
                    step++
                }, 1000 / 60)
            }

        })
    </script>
</body>

</html>