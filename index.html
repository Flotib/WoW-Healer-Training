<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>WoW Healer Training</title>
    <link rel="icon" href="img/pageicon.png" />
    <link rel="stylesheet" href="css/styles.css">
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.js"></script>
</head>

<body>
    <div id="app">
        <button @click="debugSpawnAlly">debugspawn</button>
        <button @click="addSpell">debugaddspell</button>
        <button @click="playerSetMinMana">mana 0</button>
        <button @click="playerSetMaxMana">mana 100</button>
        <button @click="player.addMana(-10)">Mana -10</button>
        <!--<input v-model="manaRegen" id="number" type="number" style="width: 35px;">-->
        <input v-model="player.haste" type="number" style="width: 50px; color: #6d3fa8" @input="statsCalculation">
        <input v-model="player.spellPower" type="number" style="width: 50px; color: #4289e6" @input="statsCalculation">
        <input v-model="player.versatility" type="number" style="width: 50px; color: #26c033" @input="statsCalculation">
        <input v-model="player.criticalStrike" type="number" style="width: 50px; color: #ff640a"
            @input="statsCalculation">
        <div style="color: white; display: inline-block;">
            {{ selectedEntity ? selectedEntity.id : 'none' }}
            <div style="color: #b3b3b3; display: inline-block; margin-left: 10px;">
                {{ selected ? selected : 'none' }}
            </div>
            <div style="color: #e44f4f; display: inline-block; margin-left: 10px;">
                {{ isPlayerCasting }}
            </div>
            <div style="color: #e4f079; display: inline-block; margin-left: 10px;">
                {{ isPlayerChanneling }}
            </div>
            <div style="color: #b3b3b3; display: inline-block; margin-left: 10px;">
                {{ keyPressed }}
            </div>
            <div style="color: #b3b3b3; display: inline-block; margin-left: 10px;">
                {{ hover }}
            </div>
            <div style="color: #8ecbee; display: inline-block; margin-left: 10px;">
                {{ holdClickHover }}
            </div>
            <div style="color: #5656ff; display: inline-block; margin-left: 10px;">
                {{ Number((player.mana).toFixed(2)) }}
            </div>
            <div style="color: #56ff5e; display: inline-block; margin-left: 10px;">
                {{ Number((player.hp).toFixed(2)) }}
            </div>
            <div style="color: #ae7eec; display: inline-block; margin-left: 10px;">
                {{ player.haste }}
            </div>
            <div style="color: #ffffff; display: inline-block; margin-left: 10px;">
                {{ Number(globalCooldown.toFixed(2)) }}
            </div>
        </div>

        <div class="flexframe">
            <div class="allyframecontainer">
                <div v-for="(ally,index) in allies" :key="index" :class="'allyhpbar' +(selected==index?' selected':'')"
                    :data-label="formatHpLabel(ally)" @click="()=>selected=index">
                    <div class="statusEffectLittleFrame">
                        <div v-for="(effect, index) in ally.activeEffects" :key="index"
                            class="statusEffectLittleFrameIcon">
                            <div class="statusEffectCooldown"
                                :style="'background: conic-gradient(#14161bb0 '+(360*(1-effect.duration/effect.baseDuration))+'deg, transparent '+(360*(1-effect.duration/effect.baseDuration))+'deg);'">
                            </div>
                            <img :src="'img/spells/' + effect.icon + '.jpg'" />
                        </div>
                    </div>
                    <div class="littleAllyHp">{{ formatlittleHpLabel(ally) }}</div>
                    <span class="allyhpvalue" :style="'width:'+ally.hp/ally.maxHp*100+'%'"></span>
                    <span v-if="ally.incomingHeal == true && ally.maxHp-ally.hp >= currentCastHeal" class="incomingHeal"
                        :style="'width:'+currentCastHeal/ally.maxHp*100+'%'"></span>
                    <span v-if="ally.incomingHeal == true && ally.maxHp-ally.hp < currentCastHeal" class="incomingHeal"
                        :style="'width:'+(ally.maxHp-ally.hp)/ally.maxHp*100+'%'"></span>
                    <span v-if="ally.hpShield > 0" class="shieldBar"
                        :style="'width:'+ally.hpShield/ally.maxHp*100+'%'"></span>
                    <span class="role"><img :src="'img/roles/'+ally.role+'.png'" /></span>
                </div>
            </div>
        </div>

        <div class="playerInterface">

            <div :class="'playerFrame' +(selected==player.id?' selected':'')" @click="()=>selected=player.id">
                <div class="playerHPbar" :data-label="Number((player.hp/player.maxHp*100).toFixed(1))+'%'">
                    <div class="statusEffectBigFrame">
                        <div v-for="(effect, index) in player.activeEffects" :key="index"
                            class="statusEffectBigFrameIcon">
                            <div class="statusEffectCooldown"
                                :style="'background: conic-gradient(#14161bb0 '+(360*(1-effect.duration/effect.baseDuration))+'deg, transparent '+(360*(1-effect.duration/effect.baseDuration))+'deg);'">
                            </div>
                            <img :src="'img/spells/' + effect.icon + '.jpg'" />
                        </div>
                    </div>
                    <span class="playerHPbarContent" :style="'width:'+player.hp/player.maxHp*100+'%'"></span>
                    <span v-if="player.incomingHeal == true && player.maxHp-player.hp >= currentCastHeal"
                        class="incomingHeal" :style="'width:'+currentCastHeal/player.maxHp*100+'%'"></span>
                    <span v-if="player.incomingHeal == true && player.maxHp-player.hp < currentCastHeal"
                        class="incomingHeal" :style="'width:'+(player.maxHp-player.hp)/player.maxHp*100+'%'"></span>
                    <span v-if="player.hpShield > 0" class="shieldBar"
                        :style="'width:'+player.hpShield/player.maxHp*100+'%'"></span>
                </div>
                <div class="playerManabar" :data-label="Number((player.mana).toFixed(1))+'%'">
                    <span class="playerManabarContent" :style="'width:'+player.mana+'%'"></span>
                </div>
            </div>

            <div class="pcastbar" :data-label="currentCastLabel">
                <div class="castbarbg" :style="'width:'+castbarBackground+'%'"></div>
                <div v-if="isPlayerCasting || isPlayerChanneling" class="castBarGlowing"
                    :style="'left:'+spellProgressBar+'%'"></div>
                <div v-if="isPlayerCasting && incantTotalTime>=400" class="spellQueueIndicator"
                    :style="'left:'+((incantTotalTime-spellQueueDelay)/incantTotalTime*100)+'%'"></div>
                <div v-if="isPlayerChanneling" class="channelTicksIndicator" v-for="i in spellchannelTicks"
                    :style="'right:'+(100/spellchannelTicks*i)+'%'"></div>
                <div :class="{ pincantationtime:isPlayerCasting, pincantationtimeChanneling:isPlayerChanneling }"
                    :style="'width:'+spellProgressBar+'%'"></div>
            </div>

            <div class="spellbar">
                <!-- Idk if the behaviour is correct but when you press the click on a spell and then release it on another spell, the spell isn't cast => @click. -->
                <div v-for="(spell,index) in spells" :key="index" class="spellcontainer" @click="()=>useSpell(spell)"
                    @mouseover="() => onSpellHover(spell)" @mouseleave="() => onSpellLeave(spell)"
                    @mousedown="holdClickHoverOn" @mouseup="holdClickHoverOff" @touchstart="holdClickHoverOn"
                    @touchend="holdClickHoverOff" @touchcancel="holdClickHoverOff">
                    <img v-if="spell.icon" :src="'img/spells/'+spell.icon+'.jpg'" />
                    <div v-if="spell.icon && (spell.mana>player.mana || spell.manapersecond>player.mana)"
                        class="notEnoughManaSpell"></div>
                    <div :class="{spellHover:!holdClickHover}"></div>
                    <div :class="{spellHoverClickHold:holdClickHover}"></div>
                    <div v-if="spell.currentCooldown != 0" class="spellCooldownBackground"
                        :style="'background: conic-gradient(transparent '+(360*(1-spell.currentCooldown/spell.cooldown))+'deg, #14161bb0 '+(360*(1-spell.currentCooldown/spell.cooldown))+'deg);'">
                    </div>
                    <div v-if="spell.currentCooldown == 0 && underGCD" class="spellCooldownBackground"
                        :style="'background: conic-gradient(transparent '+(360*(1-remainGCD/globalCooldown))+'deg, #14161bb0 '+(360*(1-remainGCD/globalCooldown))+'deg);'">
                    </div>
                    <div v-if="spell.currentCooldown != 0 && spell.currentCooldown>60000" class="spellCooldownTimer"
                        style="font-size: 20px;">{{ Math.ceil(spell.currentCooldown/1000/60) }} m</div>
                    <div v-if="spell.currentCooldown != 0 && spell.currentCooldown<=60000" class="spellCooldownTimer"
                        style="font-size: 25px;">{{ Math.ceil(spell.currentCooldown/1000) }}</div>
                </div>
            </div>

            <div class="spellTooltipPosition" v-if="hover">
                <div class="spellTooltipTitle">
                    {{ hoveredSpell.name }}
                </div>
                <div class="spellTooltipManaCost" v-if="hoveredSpell.mana>0 && !hoveredSpell.channeled">
                    {{ hoveredSpell.mana }}% Mana
                </div>
                <div class="spellTooltipManaCost" v-if="hoveredSpell.manapersecond>0 && hoveredSpell.channeled">
                    {{ hoveredSpell.manapersecond }}% Mana per second
                </div>
                <div class="spellTooltipCastTime">
                    <template v-if="hoveredSpell.incantTime>1">{{ Number((hoveredSpell.incantTime/1000).toFixed(2)) }}
                        sec cast</template>
                    <template v-else-if="hoveredSpell.incantTime==0 && !hoveredSpell.channeled">Instant</template>
                    <template v-else-if="hoveredSpell.channeled">Channeled</template>
                    <div class="spellTooltipCooldown" v-if="hoveredSpell.cooldown>0">
                        {{ Number((hoveredSpell.cooldown/1000/60).toFixed(1)) }} min cooldown
                    </div>
                </div>
                <div class="spellTooltipDesc">
                    <template v-if="!hoveredSpell.channeled">{{ replaceTooltipString(hoveredSpell.tooltip,
                        hoveredSpell.effectAmount) }}</template>
                    <template v-else>{{ replaceTooltipString(hoveredSpell.tooltip, hoveredSpell.channelEffectAmount,
                        hoveredSpell.channelTime) }}</template>
                </div>
            </div>
        </div>
    </div>

    <script>
        function rand(min, max) { // min and max included 
            return Math.floor(Math.random() * (max - min + 1) + min);
        }

        Array.prototype.removeIf = function (callback) {
            var i = 0;
            while (i < this.length) {
                if (callback(this[i], i)) {
                    this.splice(i, 1);
                }
                else {
                    ++i;
                }
            }
        }

        var app = new Vue({
            el: '#app',
            data: {
                keyPressed: false,
                globalIncrement: 0,
                selected: -1,
                currentCast: -1,
                currentCastAnim: -1,
                currentCastName: null,
                currentCastTime: null,
                currentCastHeal: null,
                spellProgressBar: 0,
                castbarBackground: 0,
                incantTotalTime: 0,
                breakIncantation: 0,
                breakChanneling: 0,
                castTimeRemaining: 0,
                channelTicksInterval: null,
                isPlayerCasting: false,
                isPlayerChanneling: false,
                hover: false,
                hoveredSpell: null,
                holdClickHover: false,
                spellInQueue: false,
                manaRegen: 0.8, // 100 * 0.008
                globalCooldown: 1500,
                remainGCD: null,
                underGCD: false,
                spellQueueDelay: 400,
                spellchannelTicks: 0,
                allies: [
                ],
                player: {
                    maxHp: 35000,
                    hp: 20000,
                    hpShield: 0,
                    mana: 100,
                    id: -1,
                    spellPower: 1000,
                    haste: 0,
                    versatility: 0,
                    criticalStrike: 0,
                    damageReduction: 0,
                    incomingHeal: false,
                    activeEffects: [],
                    addMana: function (value) {
                        this.mana = Math.max(0, Math.min(100, this.mana + value))
                    },
                    addHp: function (value) {
                        if (value < 0) {
                            value *= (1 - this.damageReduction / 100)
                        }
                        if (this.hpShield > 0 && value < 0) { // If the target have a shield and lose HP
                            if (this.hpShield + value < 0) {
                                value = value + this.hpShield
                                this.hpShield = 0
                                this.hp = Math.max(0, Math.min(this.maxHp, this.hp + value))
                            } else if (this.hpShield + value >= 0) {
                                this.hpShield = Math.max(0, Math.min(this.maxHp, this.hpShield + value))
                            }
                        } else { // If the target don't have shield and lose HP or have shield but get HP
                            this.hp = Math.max(0, Math.min(this.maxHp, this.hp + value))
                        }
                    },
                    addHpPercent: function (value) {
                        let finalValue = this.maxHp * value / 100
                        if (this.hpShield > 0 && finalValue < 0) { // If the target have a shield and lose HP
                            if (this.hpShield + finalValue < 0) {
                                finalValue = finalValue + this.hpShield
                                this.hpShield = 0
                                this.hp = Math.max(0, Math.min(this.maxHp, this.hp + finalValue))
                            } else if (this.hpShield + value >= 0) {
                                this.hpShield = Math.max(0, Math.min(this.maxHp, this.hpShield + finalValue))
                            }
                        } else { // If the target don't have shield and lose HP or have shield but get HP
                            this.hp = Math.max(0, Math.min(this.maxHp, this.hp + finalValue))
                        }
                    },
                    addShield: function (value) {
                        this.hpShield += value
                    },
                    addReduction: function (value) {
                        this.damageReduction += value
                    },
                    removeDebuff: function (value) {
                        for (const effect of this.activeEffects) {
                            if (!effect.buff && effect.type == value) {
                                effect.duration = 0
                            }
                        }
                    },
                },
                spells: [
                ],
                spellPool: {
                    Priest: [ // Name of the class which have the following spells (for the moment there is only one class because the game isn't achieved yet, obviously)
                        {
                            id: 1, // Id of the spell
                            name: "Flash Heal", // Name of the spell
                            mana: 3.6, // Mana used by the spell
                            manapersecond: 0,  // Mana per second use by the spell, used only by channeled spells
                            baseEffectAmount: 2.03, // Base heal amount, this value never change and is used by some functions
                            effectAmount: 2.03, // Same value as spell.use if the spell addHp (used for the heal amount preview)
                            tooltip: "A fast spell that heals an ally for #spellpower.",  // Tooltip of the spell which appear when the spell is hover
                            icon: "spell_holy_flashheal", // Icon of the spell
                            baseIncantTime: 1500, // Base spell incant time, this value never change and is used by some functions
                            incantTime: 1500, // Actual incant time, by default it have the same value as the base one but it change depending of the player haste
                            baseChannelTime: 0, // Same as baseIncantTime but for channeled spells
                            channelTime: 0, // Channeling time
                            channelTicks: 0, // How many time between every ticks in channeling to trigger the effect
                            channelEffectAmount: 0, // total heal amount from the channeling
                            channeled: false, // false : the spell is a normal one (castable), true : the spell is a channeled one
                            cooldown: 0, // The cooldown applied after the cast of the spell
                            currentCooldown: 0, // Current cooldown, this value change if the spell have a cooldown, after it've been used
                            affectGCD: true, // If using this spell affect the GCD
                            deadTargetEffect: 0, // 0 = false; 1 = true ==> if the spell is only usable on dead allies (only for battle rez, i think c:)
                            key: 49, // Keybinding, should change in several updates, when I'll added the key on the spellbar, not on the spell itself
                            reactToStatus: null, // Trigger an effect if the spell is cast on an entity who have the following effect id
                            applyStatus: null, // The status ID (buff or debuff) applied after the spell
                            applyStatus2: null, // Same as applyStatus but if the spell trigger a supplement status
                            use: function (game, state) {  // Function of the spell when it is used
                                game.findEntityById(state.selectedEntityId).addHp(this.effectAmount) // Here, the spell adds hp to the target
                            },
                        },
                        {
                            id: 2,
                            name: "Heal",
                            mana: 2.4,
                            manapersecond: 0,
                            baseEffectAmount: 2.95,
                            effectAmount: 2.95,
                            tooltip: "An efficient spell that heals an ally for #spellpower.",
                            icon: "spell_holy_greaterheal",
                            baseIncantTime: 2500,
                            incantTime: 2500,
                            baseChannelTime: 0,
                            channelTime: 0,
                            channelTicks: 0,
                            channelEffectAmount: 0,
                            channeled: false,
                            cooldown: 0,
                            currentCooldown: 0,
                            affectGCD: true,
                            deadTargetEffect: 0,
                            key: 50,
                            reactToStatus: null,
                            applyStatus: null,
                            applyStatus2: null,
                            use: function (game, state) {
                                game.findEntityById(state.selectedEntityId).addHp(this.effectAmount)
                            },
                        },
                        {
                            id: 3,
                            name: "Rebirth",
                            mana: 0,
                            manapersecond: 0,
                            baseEffectAmount: 0,
                            effectAmount: 0,
                            tooltip: "Returns the spirit to the body, restoring a dead target to life with 100% health. Castable in combat.",
                            icon: "spell_nature_reincarnation",
                            baseIncantTime: 2000,
                            incantTime: 2000,
                            baseChannelTime: 0,
                            channelTime: 0,
                            channelTicks: 0,
                            channelEffectAmount: 0,
                            channeled: false,
                            cooldown: 600000,
                            currentCooldown: 0,
                            affectGCD: true,
                            deadTargetEffect: 1,
                            key: 51,
                            reactToStatus: null,
                            applyStatus: null,
                            applyStatus2: null,
                            use: function (game, state) {
                                game.findEntityById(state.selectedEntityId).addHpPercent(100)
                            },
                        },
                        {
                            id: 4,
                            name: "Soothing Mist",
                            mana: 0,
                            manapersecond: 0.4,
                            baseEffectAmount: 0.55,
                            effectAmount: 0.55,
                            tooltip: "Heals the target for #spellpower over #channeltime sec.  While channeling, Enveloping Mist and Vivify may be cast instantly on the target.",
                            icon: "ability_monk_soothingmists",
                            baseIncantTime: 0,
                            incantTime: 0,
                            baseChannelTime: 8000,
                            channelTime: 8000,
                            channelTicks: 8,
                            channelEffectAmount: 4.4,
                            channeled: true,
                            cooldown: 0,
                            currentCooldown: 0,
                            affectGCD: true,
                            deadTargetEffect: 0,
                            key: 52,
                            reactToStatus: null,
                            applyStatus: null,
                            applyStatus2: null,
                            use: function (game, state) {
                                game.findEntityById(state.selectedEntityId).addHp(this.effectAmount)
                            },
                        },
                        {
                            id: 5,
                            name: "Power Word: Shield",
                            mana: 3.1,
                            manapersecond: 0,
                            baseEffectAmount: 1.65,
                            effectAmount: 1.65,
                            tooltip: "Shields an ally for 15 sec, absorbing #spellpower damage.  You cannot shield the target again for 7.5 sec.",
                            icon: "spell_holy_powerwordshield",
                            baseIncantTime: 0,
                            incantTime: 0,
                            baseChannelTime: 0,
                            channelTime: 0,
                            channelTicks: 0,
                            channelEffectAmount: 0,
                            channeled: false,
                            cooldown: 0,
                            currentCooldown: 0,
                            affectGCD: true,
                            deadTargetEffect: 0,
                            key: 53,
                            reactToStatus: 1,
                            applyStatus: 1, // good way to do this sh*t --> get buff by id and add buff to target when you ended cast the spell cast. The shield must be on the buff, not the entity :/
                            applyStatus2: 2,
                            use: function (game, state) {
                                game.findEntityById(state.selectedEntityId).addShield(0)
                            },
                        },
                    ],
                },
                statusEffects: [ // not final, still thinking about how I can do this simply without reworking all my code
                    {
                        id: 1, // id of the status effect
                        name: "test", // its name
                        buff: true, // false if it's a debuff, used to change the border color
                        type: "magic", // curse, disease, magic, poison --> for dispelling
                        baseShield: 1000,
                        shield: 1000,
                        shieldAffectedByStats: true,
                        baseEffect: 0,
                        effect: 0, // cast one time in a buff where ticks=0, else it is cast at every ticks -- applyEffect
                        effectAffectedByStats: true,
                        baseEffect2: null,
                        effect2: null, // cast one time at the start of the buff, even in an effect with ticks>0 -- applyEffect2
                        effect2AffectedByStats: true,
                        haveEndEffect: true, // effect cast one time at the end of the buff -- applyEndEffect
                        baseEndEffectValue: 100,
                        endEffectValue: 100,
                        endEffectAffectedByStats: true,
                        baseDuration: 5000, // base duration of the statusEffect
                        duration: 5000, // duration
                        ticks: 0, // number of times the effect is triggered. Null if the buff don't repeat the effect
                        tooltip: "test",
                        icon: "spell_holy_powerwordshield",
                        applyEffect: function (game, state) {
                            game.findEntityById(state.selectedEntityId).addShield(this.effect)
                        },
                        applyEndEffect: function (game, state) {
                            game.findEntityById(state.selectedEntityId).addHpPercent(100)
                        },
                    },
                    {
                        id: 2,
                        name: "test2",
                        buff: true,
                        type: "magic",
                        baseShield: 500,
                        shield: 500,
                        shieldAffectedByStats: true,
                        baseEffect: 0,
                        effect: 0,
                        effectAffectedByStats: true,
                        baseEffect2: null,
                        effect2: null,
                        effect2AffectedByStats: false,
                        haveEndEffect: false,
                        baseEndEffectValue: null,
                        endEffectValue: null,
                        endEffectAffectedByStats: false,
                        baseDuration: 5000,
                        duration: 5000,
                        ticks: 0,
                        tooltip: "test",
                        icon: "spell_holy_powerwordshield",
                        applyEffect: function (game, state) {
                            game.findEntityById(state.selectedEntityId).addShield(this.effect)
                        },
                        applyEndEffect: function (game, state) {
                            game.findEntityById(state.selectedEntityId).addHpPercent(this.endEffectValue)
                        },
                    },
                ],
            },

            computed: {
                selectedEntity() {
                    if (this.selected == this.player.id) {
                        return this.player;
                    } else {
                        return this.allies[this.selected];
                    }
                },

                currentCastLabel() {
                    if (this.currentCast != -1) {
                        return this.currentCastName //+ " " + this.currentCastTime;
                    }
                },

            },

            methods: {
                onSpellHover(spell) {
                    if (!spell.name) {
                        return;
                    }

                    this.hover = true;
                    this.hoveredSpell = spell;
                },

                onSpellLeave(spell) {
                    if (this.hoveredSpell?.name == spell.name) {
                        this.hover = false;
                        this.hoveredSpell = null;
                        this.holdClickHover = false;
                    }
                },

                holdClickHoverOn() {
                    if (this.hoveredSpell) {
                        this.holdClickHover = true
                    }
                },

                holdClickHoverOff() {
                    this.holdClickHover = false
                },

                replaceTooltipString(source, spellPowerValue, channelTimeValue) {
                    source = source.replace('#spellpower', Number((spellPowerValue).toFixed(0)))
                    source = source.replace('#channeltime', Number((channelTimeValue / 1000).toFixed(2)))
                    return source
                },

                breakUseSpell() {
                    clearTimeout(this.currentCast)
                    this.currentCastAnim = -1
                    this.currentCast = -1
                    this.spellProgressBar = 0
                    this.castbarBackground = 0
                    this.currentCastName = null
                    this.isPlayerCasting = false
                    this.isPlayerChanneling = false
                    this.castTimeRemaining = 0
                    this.currentCastHeal = null
                },

                breakSpellAnimation() { // less instable than breakUseSpell
                    clearTimeout(this.currentCast)
                    this.currentCastAnim = -1
                    this.currentCastHeal = null
                    this.castbarBackground = 0
                    this.castTimeRemaining = 0
                    this.spellProgressBar = 0
                },

                addAlly(number, desiredRole) {
                    for (let i = 0; i < number; i++) {
                        this.allies.push({
                            maxHp: 20000,
                            hp: Math.random() * 20000,
                            hpShield: 0,
                            role: desiredRole, //["tank", "healer", "dps"][rand(0, 2)],
                            getProperRole: false,
                            id: ++this.globalIncrement,
                            damageReduction: 0,
                            incomingHeal: false,
                            activeEffects: [],
                            addHp: function (value) {
                                if (value < 0) {
                                    value *= (1 - this.damageReduction / 100)
                                }
                                if (this.hpShield > 0 && value < 0) { // If the target have a shield and lose HP
                                    if (this.hpShield + value < 0) {
                                        value = value + this.hpShield
                                        this.hpShield = 0
                                        this.hp = Math.max(0, Math.min(this.maxHp, this.hp + value))
                                    } else if (this.hpShield + value >= 0) {
                                        this.hpShield = Math.max(0, Math.min(this.maxHp, this.hpShield + value))
                                    }
                                } else { // If the target don't have shield and lose HP or have shield but get HP
                                    this.hp = Math.max(0, Math.min(this.maxHp, this.hp + value))
                                }
                            },
                            addHpPercent: function (value) {
                                let finalValue = this.maxHp * value / 100
                                if (this.hpShield > 0 && finalValue < 0) { // If the target have a shield and lose HP
                                    if (this.hpShield + finalValue < 0) {
                                        finalValue = finalValue + this.hpShield
                                        this.hpShield = 0
                                        this.hp = Math.max(0, Math.min(this.maxHp, this.hp + finalValue))
                                    } else if (this.hpShield + value >= 0) {
                                        this.hpShield = Math.max(0, Math.min(this.maxHp, this.hpShield + finalValue))
                                    }
                                } else { // If the target don't have shield and lose HP or have shield but get HP
                                    this.hp = Math.max(0, Math.min(this.maxHp, this.hp + finalValue))
                                }
                            },
                            addShield: function (value) {
                                this.hpShield += value
                            },
                            addReduction: function (value) {
                                this.damageReduction += value
                            },
                            removeDebuff: function (value) {
                                for (const effect of this.activeEffects) {
                                    if (!effect.buff && effect.type == value) {
                                        effect.duration = 0
                                    }
                                }
                            },
                        })
                    }
                },

                changeAllyHpByRole() {
                    for (const ally of this.allies) {
                        if (!ally.getProperRole) {
                            if (ally.role == "tank") {
                                ally.maxHp = 60000
                                ally.hp = 60000
                                ally.damageReduction = 10
                            } else {
                                ally.maxHp = rand(3000, 3950) * 10
                                ally.hp = rand(1, ally.maxHp) //toDo : set to ally.maxHp -- math random for tests
                            }
                            ally.getProperRole = true
                        }
                    }
                },

                cooldownSubstract(spell) {
                    setTimeout(() => {
                        spell.currentCooldown -= 1000 / 20
                        if (spell.currentCooldown > 0) {
                            this.cooldownSubstract(spell)
                        }
                    }, 1000 / 20)
                },

                globalCooldownFunction() {
                    this.underGCD = true
                    this.remainGCD = this.globalCooldown
                    const darkmoon = () => {
                        this.remainGCD -= 1000 / 60
                        if (Math.round(this.remainGCD) > 0) {
                            setTimeout(darkmoon, 1000 / 60);
                        } else {
                            this.remainGCD = null
                            this.underGCD = false
                        }
                    }
                    setTimeout(darkmoon, 1000 / 60);
                },

                findEntityById(id) {
                    if (id == this.player.id) {
                        return this.player
                    } else {
                        for (const ally of this.allies) {
                            if (ally.id == id) {
                                return ally;
                            }
                        }

                        return null;
                    }
                },

                findStatusEffectById(id) {
                    for (const statusEffect of this.statusEffects) {
                        if (statusEffect.id == id) {
                            return statusEffect;
                        }
                    }

                    return null;
                },

                spellReactionToEffect(target, spell) {
                    for (const targetEffect of target.activeEffects) {
                        if (targetEffect.id == spell.reactToStatus) {
                            return true
                        }
                    }
                    return false
                },

                formatHpLabel(ally) {
                    if (ally.hp <= 0) {
                        return "dead"
                    }

                    return Math.ceil(ally.hp / ally.maxHp * 100) + '%'
                },

                formatlittleHpLabel(ally) { // toggle option later, show the real hp
                    if (ally.hp <= 0) { // can also disable this if to show "0 / maxHp" which is pretty good looking
                        return ""
                    }

                    return Math.ceil(ally.hp) + " / " + Math.ceil(ally.maxHp)
                },

                formatHpShieldTabel(ally) {

                },

                addSpell() {
                    this.spells.push({})
                },

                debugSpawnAlly() {
                    this.addAlly(1, ['tank', 'healer', 'dps'][rand(0, 2)])
                    this.changeAllyHpByRole()
                },

                playerSetMaxMana() {
                    this.player.mana = 100
                },

                playerSetMinMana() {
                    this.player.mana = 0
                },

                statsCalculation() { // toDo : do the same for effects
                    for (const spell of this.spells) {
                        //haste
                        spell.incantTime = spell.baseIncantTime / (1 + this.player.haste / 100)
                        spell.channelTime = spell.baseChannelTime / (1 + this.player.haste / 100)
                        this.globalCooldown = 1500 / (1 + this.player.haste / 100) // 1500 for baseGCD, if it cause problems later ==> create a var baseGCD in data
                        //spellpower & versatility
                        spell.effectAmount = Math.ceil(spell.baseEffectAmount * this.player.spellPower * (1 + this.player.versatility / 100))
                        if (spell.channeled) {
                            spell.channelEffectAmount = Math.ceil(spell.baseEffectAmount * this.player.spellPower * (1 + this.player.versatility / 100)) * spell.channelTicks
                        }
                    }
                    for (const effect of this.statusEffects) {
                        //spellpower & versatility
                        if (effect.shieldAffectedByStats) {
                            effect.shield = Math.ceil(effect.baseShield * this.player.spellPower * (1 + this.player.versatility / 100))
                        }
                        if (effect.effectAffectedByStats) {
                            effect.effect = Math.ceil(effect.baseEffect * this.player.spellPower * (1 + this.player.versatility / 100))
                        }
                        if (effect.effect2AffectedByStats) {
                            effect.effect2 = Math.ceil(effect.baseEffect2 * this.player.spellPower * (1 + this.player.versatility / 100))
                        }
                        if (effect.endEffectAffectedByStats) {
                            effect.endEffectValue = Math.ceil(effect.baseEndEffectValue * this.player.spellPower * (1 + this.player.versatility / 100))
                        }
                    }
                },

                selectClass(clazz) {
                    this.spells.length = 0;

                    for (const spell of this.spellPool[clazz]) {
                        this.spells.push({
                            ...spell,
                        });
                    }

                    const totalspells = 24 - this.spells.length
                    for (let i = 0; i < totalspells; i++) {
                        this.addSpell()
                    }
                },

                useSpell(spell) {
                    const selectedEntityId = this.selectedEntity.id
                    if (this.spellReactionToEffect(this.findEntityById(selectedEntityId), spell)) { // if spell react to a buff/debuff
                        if (spell.id == 5) { // Power Word: Shield
                            return
                        }
                    }
                    if (spell.currentCooldown <= 0 && this.player.mana - spell.mana >= 0 && this.player.mana - spell.manapersecond >= 0) {
                        if (!spell.channeled) {
                            /*if (spell.incantTime <= 1000) {  // change the spellQueue delay if the spell incant time is lower than 1sec
                                this.spellQueueDelay = spell.incantTime * 0.5
                            }*/
                            this.breakIncantation = 0
                            this.breakChanneling = 0
                            if (this.isPlayerCasting && this.castTimeRemaining > this.spellQueueDelay) { // If it's a different spell, cancel the one currently being cast and cast the new one
                                //this.breakIncantation = 1
                                //this.breakUseSpell()
                                return

                            } else if (this.isPlayerCasting && this.castTimeRemaining <= this.spellQueueDelay && !this.spellInQueue) { // ADD TO QUEUE (chain spell)
                                if (!this.underGCD) {
                                    this.spellInQueue = true
                                    setTimeout(() => {
                                        this.spellInQueue = false
                                        this.useSpell(spell)
                                    }, this.castTimeRemaining)
                                    return
                                } else if (this.underGCD && this.castTimeRemaining <= this.remainGCD + 25) {
                                    this.spellInQueue = true
                                    setTimeout(() => {
                                        this.spellInQueue = false
                                        this.useSpell(spell)
                                    }, this.remainGCD + 25)
                                    return
                                } else { return }
                            }
                            if (!this.underGCD) { // verify if there is the GCD
                                if (this.isPlayerChanneling) { //toDo : when Soothing Mist is channeled the monk can use some spells instantly - 1500 gcd if instacast unlike all others monk abilities
                                    this.breakChanneling = 1
                                    this.isPlayerChanneling = false
                                    this.castTimeRemaining = 0
                                }
                                if (this.spellInQueue) { return }
                                if (spell.incantTime > 0) {
                                    this.currentCastName = spell.name
                                }
                                if (spell.deadTargetEffect == 0) { // Verify if the spell is a healing spell or a battle rez one and then verify if the target can be heal / rez
                                    if (this.findEntityById(selectedEntityId).hp <= 0) { // healing spell (break if target is dead)
                                        this.breakUseSpell()
                                        return
                                    }
                                } else {
                                    if (this.findEntityById(selectedEntityId).hp > 0) { // brez (break if target is alive)
                                        this.breakUseSpell()
                                        return
                                    }
                                }
                                if (spell.affectGCD) {
                                    this.globalCooldownFunction()
                                }
                                if (spell.effectAmount > 0 && spell.baseIncantTime > 0) {
                                    this.currentCastHeal = spell.effectAmount
                                    this.findEntityById(selectedEntityId).incomingHeal = true
                                }
                                this.currentCast = 1
                                this.incantTotalTime = spell.incantTime;
                                let remain = spell.incantTime;
                                let whle = () => {
                                    if (this.breakIncantation == 1) { //break casting
                                        this.breakIncantation = 0
                                        this.findEntityById(selectedEntityId).incomingHeal = false
                                        this.breakSpellAnimation()
                                        return
                                    } else if (this.breakIncantation == 2) { //escape key
                                        this.breakIncantation = 0
                                        this.findEntityById(selectedEntityId).incomingHeal = false
                                        this.breakUseSpell()
                                        return
                                    }
                                    remain -= 1000 / 60
                                    this.castTimeRemaining = remain
                                    this.isPlayerCasting = true
                                    this.castbarBackground = 100
                                    this.currentCastTime = (remain / 1000 / 60)
                                    this.spellProgressBar = 100 - remain / spell.incantTime * 100
                                    if (this.player.mana - spell.mana < 0) {
                                        this.findEntityById(selectedEntityId).incomingHeal = false
                                        this.breakUseSpell()
                                        return
                                    }
                                    if (spell.deadTargetEffect == 0) {
                                        if (this.findEntityById(selectedEntityId).hp <= 0) {
                                            this.findEntityById(selectedEntityId).incomingHeal = false
                                            this.breakUseSpell()
                                            return
                                        }
                                    } /*else if (this.findEntityById(selectedEntityId).hp > 0) {
                                     this.breakUseSpell()
                                     return
                                    } This part is broken, and a lil' bit useless*/

                                    if (Math.round(remain) > 0) {
                                        this.currentCastAnim = setTimeout(whle, 1000 / 60);
                                    } else {
                                        spell.use(this, { selectedEntityId })
                                        if (spell.applyStatus != null) {
                                            this.applyStatusEffect(this.findEntityById(selectedEntityId), this.findStatusEffectById(spell.applyStatus))

                                            if (spell.applyStatus2 != null) {
                                                this.applyStatusEffect(this.findEntityById(selectedEntityId), this.findStatusEffectById(spell.applyStatus2))
                                            }
                                        }
                                        spell.currentCooldown = spell.cooldown
                                        this.player.addMana(-spell.mana)
                                        this.currentCastAnim = -1
                                        this.currentCast = -1
                                        this.currentCastHeal = null
                                        this.findEntityById(selectedEntityId).incomingHeal = false
                                        this.spellProgressBar = 0
                                        this.castbarBackground = 0
                                        this.currentCastName = null
                                        this.isPlayerCasting = false
                                        this.castTimeRemaining = 0
                                        if (spell.cooldown > 0) {
                                            this.cooldownSubstract(spell)
                                        }
                                        return
                                    }
                                }
                                this.currentCastAnim = setTimeout(whle, 1000 / 60);
                            }
                        }


                        else { // spell is channeled
                            this.breakIncantation = 0
                            this.breakChanneling = 0
                            if (!this.underGCD) {
                                if (spell.name == this.currentCastName) {
                                    this.breakChanneling = 1
                                }
                                if (this.isPlayerCasting) { return }
                                this.currentCastName = spell.name
                                const selectedEntityId = this.selectedEntity.id
                                if (spell.deadTargetEffect == 0) { // verify if target is dead
                                    if (this.findEntityById(selectedEntityId).hp <= 0) { // healing spell (break if target is dead)
                                        this.breakUseSpell()
                                        return
                                    }
                                }
                                if (spell.affectGCD) {
                                    this.globalCooldownFunction()
                                }
                                this.currentCast = 1
                                this.incantChannelTime = spell.channelTime;
                                this.channelTicksInterval = spell.channelTime / spell.channelTicks // channeled ticks interval's now here
                                let remain = spell.channelTime;
                                let ticks = this.channelTicksInterval
                                let whle = () => {
                                    if (this.breakChanneling == 1) { //break casting
                                        this.breakChanneling = 0
                                        this.breakSpellAnimation()
                                        return
                                    } else if (this.breakChanneling == 2) { //escape key
                                        this.breakChanneling = 0
                                        this.breakUseSpell()
                                        return
                                    }
                                    remain -= 1000 / 60
                                    ticks -= 1000 / 60
                                    this.castTimeRemaining = remain
                                    this.spellchannelTicks = spell.channelTicks
                                    this.isPlayerChanneling = true
                                    this.castbarBackground = 100
                                    this.currentCastTime = (remain / 1000 / 60)
                                    this.spellProgressBar = remain / spell.channelTime * 100
                                    if (this.player.mana - spell.manapersecond < 0) {
                                        this.breakUseSpell()
                                        return
                                    }
                                    if (spell.deadTargetEffect == 0) {
                                        if (this.findEntityById(selectedEntityId).hp <= 0) {
                                            this.breakUseSpell()
                                            return
                                        }
                                    }
                                    if (Math.round(ticks) <= 0) { // round to avoid a value like 8.0e-13 =)
                                        spell.use(this, { selectedEntityId })
                                        this.player.addMana(-spell.manapersecond)
                                        ticks = this.channelTicksInterval - 1000 / 60
                                    }
                                    if (Math.round(remain) > 0) {
                                        this.currentCastAnim = setTimeout(whle, 1000 / 60);
                                    } else {
                                        spell.currentCooldown = spell.cooldown
                                        this.currentCastAnim = -1
                                        this.currentCast = -1
                                        this.spellProgressBar = 0
                                        this.castbarBackground = 0
                                        this.currentCastName = null
                                        this.isPlayerChanneling = false
                                        this.castTimeRemaining = 0
                                        if (spell.cooldown > 0) {
                                            this.cooldownSubstract(spell)
                                        }
                                        return
                                    }
                                }
                                this.currentCastAnim = setTimeout(whle, 1000 / 60);
                            }
                        }
                    }
                },

                applyStatusEffect(target, effect) {
                    let previous = target.activeEffects.filter((x) => x.id == effect.id)[0]

                    if (previous !== undefined) {
                        previous.duration = effect.baseDuration
                    } else {
                        effect = { ...effect }

                        target.activeEffects.push(effect)

                        effect.duration = effect.baseDuration
                        let selectedEntityId = this.selectedEntity.id

                        if (effect.ticks != null) {
                            let ticksInterval = effect.baseDuration / effect.ticks
                            if (effect.baseEffect2 != null) {
                                effect.applyEffect2(this, { selectedEntityId })
                            }
                            let elune = () => {
                                if (target.hp <= 0) {
                                    effect.duration = 0
                                    target.activeEffects.removeIf((x) => x.id == effect.id)
                                    return
                                }
                                effect.duration -= 1000 / 20
                                ticksInterval -= 1000 / 20
                                if (Math.round(ticksInterval) <= 0) {
                                    effect.applyEffect(this, { selectedEntityId })
                                    ticksInterval = effect.baseDuration / effect.ticks - 1000 / 20
                                }
                                if (Math.round(effect.duration) > 0) {
                                    setTimeout(elune, 1000 / 20)
                                } else {
                                    if (effect.haveEndEffect) {
                                        effect.applyEndEffect(this, { selectedEntityId })
                                    }

                                    target.activeEffects.removeIf((x) => x.id == effect.id)

                                    return
                                }
                            }
                            setTimeout(elune, 1000 / 20);

                        } else { // no ticks
                            if (effect.baseEffect != null) {
                                effect.applyEffect(this, { selectedEntityId })
                                if (effect.baseEffect2 != null) {
                                    effect.applyEffect2(this, { selectedEntityId })
                                }
                            }
                            let elune = () => {
                                if (target.hp <= 0) {
                                    effect.duration = 0
                                    target.activeEffects.removeIf((x) => x.id == effect.id)
                                    return
                                }
                                console.log(effect.duration)
                                effect.duration -= 1000 / 20
                                if (Math.round(effect.duration) > 0) {
                                    setTimeout(elune, 1000 / 20)
                                } else {
                                    if (effect.haveEndEffect) {
                                        effect.applyEndEffect(this, { selectedEntityId })
                                    }

                                    target.activeEffects.removeIf((x) => x.id == effect.id)

                                    return
                                }
                            }
                            setTimeout(elune, 1000 / 20);
                        }
                    }
                },
            },

            mounted() {

                document.addEventListener("keydown", (event) => { // Detect if the pressed key is used by a spell, and if so, cast this spell
                    if (this.keyPressed) return;
                    this.keyPressed = true;
                    for (const spell of this.spells) {
                        if (spell.key == event.keyCode) {
                            this.useSpell(spell)
                            break
                        }
                    }


                    if (event.keyCode == 27) { // esc key role --> break cast and if not casting target player
                        if (this.castTimeRemaining > 0) {
                            this.breakIncantation = 2
                            this.breakChanneling = 2
                        } else {
                            this.selected = -1
                        }
                    }
                }, false);

                document.addEventListener("keyup", (event) => {
                    this.keyPressed = false;
                }, false);

                this.selectClass("Priest");

                this.statsCalculation()

                this.addAlly(2, "tank");
                this.addAlly(2, "healer");
                this.addAlly(10, "dps");

                this.changeAllyHpByRole()

                let step = 0;

                setInterval(() => {
                    if (step % 60 == 0) {
                        for (const ally of this.allies) {
                            ally.addHp(-ally.maxHp / 100)
                        }
                        this.player.addMana(this.manaRegen)
                    }
                    step++
                }, 1000 / 60)
            }

        })
    </script>
</body>

</html>