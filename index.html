<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>WoW Healer Training</title>
    <link rel="icon" href="img/pageicon.png" />
    <link rel="stylesheet" href="css/styles.css">
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.js"></script>
</head>

<body>
    <div id="app">
        <div v-if="!choseClass" class="classSelectionScreen">
            <div  v-for="clazz in classes" class="hoverScaleClassMenu">
            <div :class="'classContainer' +(selectedClazz==clazz.name?' classContainerSelected':'')" @click="selectedClazz = clazz.name">
                <img :src="'img/classes/'+clazz.name+'.png'" class="classIconSelection"/>
            </div>
        </div>
            <button :class="{ buttonValidateGrey:!selectedClazz, buttonValidate:selectedClazz }" @click="choseClass=true; selectClass(selectedClazz)">Accept</button>
        </div>
        <div v-if="choseClass">
            <div class="backgroundImage" :style="'background-color: '+backgroundColor+';'"></div>
            <div v-if="toggleBackgroundImage" class="backgroundImage"
                :style="'background-image: url'+backgroundImage+'; filter: blur('+backgroundBlurValue/10+'px);'">
                <div v-if="toggleBackgroundImageVignette" class="backgroundOverlap"></div>
            </div>
            <div>
                <button @click="debugSpawnAlly">debugspawn</button>
                <button @click="removeLastAlly">debugdespawn</button>
                <button @click="removeAllAllies">debugdespawnall</button>
                <button @click="killAllAllies">kill all</button>
                <button @click="reviveAllAllies">revive all</button>
                <button @click="addSpell">debugaddspell</button>
                <button @click="playerSetMinMana">mana 0</button>
                <button @click="playerSetMaxMana">mana 100</button>
                <button @click="player.addMana(-10)">Mana -10</button>
                <!--<input v-model="manaRegen" id="number" type="number" style="width: 35px;">-->
                <input v-model="player.spellPower" type="number" style="width: 50px; color: #4289e6; font-weight: 600;"
                    @input="statsCalculation">
                <input v-model="player.haste" type="number" style="width: 50px; color: #9b4eff; font-weight: 600;"
                    @input="statsCalculation">
                <input v-model="player.versatility" type="number" style="width: 50px; color: #26c033; font-weight: 600;"
                    @input="statsCalculation">
                <input v-model="player.criticalStrike" type="number"
                    style="width: 50px; color: #ff640a; font-weight: 600;" @input="statsCalculation">
                <input v-model="player.mastery" type="number" style="width: 50px; color: #ff58cd; font-weight: 600;"
                    @input="statsCalculation">
                <div style="color: white; display: inline-block;">
                    {{ selectedEntity ? selectedEntity.id : 'none' }}
                    <div style="color: #b3b3b3; display: inline-block; margin-left: 10px;">
                        {{ selected ? selected : 'none' }}
                    </div>
                    <div style="color: #e44f4f; display: inline-block; margin-left: 10px;">
                        {{ isPlayerCasting }}
                    </div>
                    <div style="color: #e4f079; display: inline-block; margin-left: 10px;">
                        {{ isPlayerChanneling }}
                    </div>
                    <div style="color: #b3b3b3; display: inline-block; margin-left: 10px;">
                        {{ keyPressed }}
                    </div>
                    <div style="color: #b3b3b3; display: inline-block; margin-left: 10px;">
                        {{ hover }}
                    </div>
                    <div style="color: #8ecbee; display: inline-block; margin-left: 10px;">
                        {{ holdClickHover }}
                    </div>
                    <div style="color: #5656ff; display: inline-block; margin-left: 10px;">
                        {{ (player.mana).toFixed(2) }}
                    </div>
                    <div style="color: #56ff5e; display: inline-block; margin-left: 10px;">
                        {{ Number((player.hp).toFixed(2)) }}
                    </div>
                    <div style="color: #ae7eec; display: inline-block; margin-left: 10px;">
                        {{ player.haste }}
                    </div>
                    <div style="color: #ffffff; display: inline-block; margin-left: 10px;">
                        {{ Number(globalCooldown.toFixed(2)) }}
                    </div>
                    <div style="color: #ffffff; display: inline-block; margin-left: 10px;">
                        {{ player.specialPower }} - {{ player.maxSpecialPower }}
                    </div>
                    <button @click="selectClass('Priest')"
                        :style="'margin-left: 10px; color:'+classes.Priest.color+'; background-color: black;'">Priest</button>
                    <button @click="selectClass('Monk')"
                        :style="'margin-left: 10px; color:'+classes.Monk.color+'; background-color: black;'">Monk</button>
                    <button @click="selectClass('Druid')"
                        :style="'margin-left: 10px; color:'+classes.Druid.color+'; background-color: black;'">Druid</button>
                    <button @click="selectClass('Paladin')"
                        :style="'margin-left: 10px; color:'+classes.Paladin.color+'; background-color: black;'">Paladin</button>
                    <button @click="selectClass('Shaman')"
                        :style="'margin-left: 10px; color:'+classes.Shaman.color+'; background-color: black;'">Shaman</button>
                </div>

                <div class="flexframe">
                    <div class="rightMenuArea">
                        <input id="rmenubuttoninput" type="checkbox" />
                        <div class="rightMenuButton">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                        <div class="rightMenu">
                            <h2
                                style="border: 1px solid #fff; padding: 5px 15px 5px 15px; text-shadow: #ff0000 0px 0 16px; font-weight: 400; margin-bottom: 10px;">
                                Group composition</h2>
                            <div style="margin-top: 10px;">
                                <h3 style="font-weight: 400; color: #FF7D01">Raid :</h3>
                                <!--Minus 1 healer because... Player is one of them-->
                                <!--<div style="box-shadow: #ff7c01 0px 0 8px; width: 250px; background-color: #ff7c01;">-->
                                <button
                                    @click="removeAllAllies(); addAlly(2, 'tank'); addAlly(1, 'healer'); addAlly(6, 'dps'); changeAllyHpByRole();">2<img
                                        src="img/roles/tank.png">2<img src="img/roles/healer.png">6<img
                                        src="img/roles/dps.png"></button>
                                <button
                                    @click="removeAllAllies(); addAlly(2, 'tank'); addAlly(2, 'healer'); addAlly(9, 'dps'); changeAllyHpByRole();">2<img
                                        src="img/roles/tank.png">3<img src="img/roles/healer.png">9<img
                                        src="img/roles/dps.png"></button>
                                <button
                                    @click="removeAllAllies(); addAlly(2, 'tank'); addAlly(3, 'healer'); addAlly(14, 'dps'); changeAllyHpByRole();">2<img
                                        src="img/roles/tank.png">4<img src="img/roles/healer.png">14<img
                                        src="img/roles/dps.png"></button>
                                <!--</div>-->
                            </div>
                            <div style="margin-top: 15px;">
                                <h3 style="font-weight: 400; color: #AAABFE">Party :</h3>
                                <button @click="removeAllAllies(); addAlly(1, 'tank'); addAlly(3, 'dps'); changeAllyHpByRole();">1<img
                                        src="img/roles/tank.png">1<img src="img/roles/healer.png">3<img
                                        src="img/roles/dps.png"></button>
                            </div>
                            <div style="margin: 15px 0px 25px 0px;">
                                <h3 style="font-weight: 400; color: #E6CC80">Custom :</h3>
                                <div style="display: inline-flex;">
                                    <img src="img/roles/tank.png" style="transform: scale(0.8);"><input type="number"
                                        v-model="allyTank" class="rightMenuCustomInput">
                                    <img src="img/roles/healer.png" style="transform: scale(0.8);"><input type="number"
                                        v-model="allyHealer" class="rightMenuCustomInput">
                                    <img src="img/roles/dps.png" style="transform: scale(0.8);"><input type="number"
                                        v-model="allyDps" class="rightMenuCustomInput">
                                </div>
                                <button
                                    @click="removeAllAllies(); addAlly(allyTank, 'tank'); addAlly(allyHealer, 'healer'); addAlly(allyDps, 'dps'); changeAllyHpByRole();">Apply</button>
                            </div>
                            <hr style="width: 75%; margin-bottom: 25px;">
                            <h2
                                style="border: 1px solid #fff; padding: 5px 15px 5px 15px; text-shadow: #ff0000 0px 0 16px; font-weight: 400; margin-bottom: 10px;">
                                Background settings</h2>
                            <div class="carousel">
                                <ul class="slides">
                                    <input type="radio" name="radio-buttons" id="img-1" checked />
                                    <li class="slide-container">
                                        <div class="slide-image">
                                            <img src="img/bg/northshire.jpg">
                                        </div>
                                    </li>
                                    <input type="radio" name="radio-buttons" id="img-2" />
                                    <li class="slide-container">
                                        <div class="slide-image">
                                            <img src="img/bg/onyxia.jpg">
                                        </div>
                                    </li>
                                    <input type="radio" name="radio-buttons" id="img-3" />
                                    <li class="slide-container">
                                        <div class="slide-image">
                                            <img src="img/bg/ragnaros.jpg">
                                        </div>
                                    </li>
                                    <div class="carousel-dots">
                                        <label for="img-1" class="carousel-dot" id="img-dot-1"
                                            @click="backgroundImage = '(img/bg/northshire.jpg)'"
                                            style="background-image: url(img/bg/northshire.jpg);"></label>
                                        <label for="img-2" class="carousel-dot" id="img-dot-2"
                                            @click="backgroundImage = '(img/bg/onyxia.jpg);'"
                                            style="background-image: url(img/bg/onyxia.jpg);"></label>
                                        <label for="img-3" class="carousel-dot" id="img-dot-3"
                                            @click="backgroundImage = '(img/bg/ragnaros.jpg)'"
                                            style="background-image: url(img/bg/ragnaros.jpg);"></label>
                                    </div>
                                </ul>
                            </div>
                            <button style="margin-top: 10px;"
                                @click="toggleBackgroundImage = !toggleBackgroundImage; if(backgroundImage==null){backgroundImage='(img/bg/northshire.jpg)'}">Background
                                image on/off</button>
                            <button style="margin-top: 10px;"
                                @click="toggleBackgroundImageVignette = !toggleBackgroundImageVignette">Image
                                vignette on/off</button>
                            <div style="margin-top: 10px;">
                                <h3 style="font-weight: 400; font-size: 16px;">Blur : {{ backgroundBlurValue }}%</h3>
                                <input type="range" class="customSliderMenu" v-model="backgroundBlurValue">
                            </div>
                            <div style="margin-top: 10px; display: inline-flex; align-items: center;">
                                <h3 style="margin-right: 15px; font-weight: 400; font-size: 16px;">Background color :
                                </h3>
                                <input type="color" v-model="backgroundColor">
                                <div v-if="backgroundColor == defaultBackgroundColor" style="width: 35px;"></div>
                                <button v-if="backgroundColor != defaultBackgroundColor"
                                    @click="backgroundColor = defaultBackgroundColor"
                                    style="width: 35px; height: 24px; padding: 0px; margin: 0px;">X</button>
                            </div>
                        </div>
                    </div>

                    <div class="allyframecontainer">
                        <div v-for="(ally,index) in allies" :key="index"
                            :class="'allyhpbar' +(selected==index?' selected':'')" :data-label="formatHpLabel(ally)"
                            @click="()=>selected=index">
                            <!-- @mouseover="()=>selected=index" -->
                            <div class="statusEffectLittleFrame">
                                <div v-for="(effect, index) in ally.activeEffects" :key="index"
                                    class="statusEffectLittleFrameIcon"
                                    v-bind:style="effect.buff ? 'border-color: #a5a5a5;' : 'border-color: #d10606;'">
                                    <div class="statusEffectCooldown"
                                        :style="'background: conic-gradient(#14161bb0 '+(360*(1-effect.duration/effect.maxDuration))+'deg, transparent '+(360*(1-effect.duration/effect.maxDuration))+'deg);'">
                                    </div>
                                    <img :src="'img/spells/' + effect.icon + '.jpg'" />
                                </div>
                            </div>
                            <div class="littleAllyHp">{{ formatlittleHpLabel(ally) }}</div>
                            <span class="allyhpvalue" :style="'width:'+ally.hp/ally.maxHp*100+'%'"></span>
                            <span v-if="ally.incomingHeal == true && ally.maxHp-ally.hp >= currentCastHeal"
                                class="incomingHeal" :style="'width:'+currentCastHeal/ally.maxHp*100+'%'"></span>
                            <span v-if="ally.incomingHeal == true && ally.maxHp-ally.hp < currentCastHeal"
                                class="incomingHeal" :style="'width:'+(ally.maxHp-ally.hp)/ally.maxHp*100+'%'"></span>
                            <span v-if="ally.hpShield > 0" class="shieldBar"
                                :style="'width:'+ally.hpShield/ally.maxHp*100+'%'"></span>
                            <span class="role"><img :src="'img/roles/'+ally.role+'.png'" /></span>
                        </div>
                    </div>
                </div>

                <div class="playerInterface">
                    <div :class="'playerFrame' +(selected==player.id?' selected':'')" @click="()=>selected=player.id">
                        <div class="playerHPbar" :data-label="Number((player.hp/player.maxHp*100).toFixed(1))+'%'">
                            <div class="statusEffectBigFrame">
                                <div v-if="player.maxSpecialPower > 0" class="playerSpecialPower">
                                    <div v-for="specialPower in player.maxSpecialPower-player.specialPower" class="emptyPaladinPower"></div>
                                    <div v-for="specialPower in player.specialPower"
                                        class="fullPaladinPower">
                                    </div>
                                </div>
                                <div v-for="(effect, index) in player.activeEffects" :key="index"
                                    class="statusEffectBigFrameIcon"
                                    v-bind:style="effect.buff ? 'border-color: #a5a5a5;' : 'border-color: #d10606;'">
                                    <div class="statusEffectCooldown"
                                        :style="'background: conic-gradient(#14161bb0 '+(360*(1-effect.duration/effect.maxDuration))+'deg, transparent '+(360*(1-effect.duration/effect.maxDuration))+'deg);'">
                                    </div>
                                    <img :src="'img/spells/' + effect.icon + '.jpg'" />
                                </div>
                            </div>
                            <span class="playerHPbarContent" :style="'width:'+player.hp/player.maxHp*100+'%'"></span>
                            <span v-if="player.incomingHeal == true && player.maxHp-player.hp >= currentCastHeal"
                                class="incomingHeal" :style="'width:'+currentCastHeal/player.maxHp*100+'%'"></span>
                            <span v-if="player.incomingHeal == true && player.maxHp-player.hp < currentCastHeal"
                                class="incomingHeal"
                                :style="'width:'+(player.maxHp-player.hp)/player.maxHp*100+'%'"></span>
                            <span v-if="player.hpShield > 0" class="shieldBar"
                                :style="'width:'+player.hpShield/player.maxHp*100+'%'"></span>
                        </div>
                        <div class="playerManabar" :data-label="Number((player.mana).toFixed(1))+'%'">
                            <span class="playerManabarContent" :style="'width:'+player.mana+'%'"></span>
                        </div>
                    </div>

                    <div class="pcastbar" :data-label="currentCastLabel">
                        <div class="castbarbg" :style="'width:'+castbarBackground+'%'"></div>
                        <div v-if="isPlayerCasting || isPlayerChanneling" class="castBarGlowing"
                            :style="'left:'+spellProgressBar+'%'"></div>
                        <div v-if="isPlayerCasting && incantTotalTime>=400" class="spellQueueIndicator"
                            :style="'left:'+((incantTotalTime-spellQueueDelay)/incantTotalTime*100)+'%'"></div>
                        <div v-if="isPlayerChanneling" class="channelTicksIndicator" v-for="i in spellchannelTicks"
                            :style="'right:'+(100/spellchannelTicks*i)+'%'"></div>
                        <div :class="{ pincantationtime:isPlayerCasting, pincantationtimeChanneling:isPlayerChanneling }"
                            :style="'width:'+spellProgressBar+'%'"></div>
                    </div>

                    <div class="spellbar">
                        <div v-for="(spell,index) in spells" :key="index" class="spellcontainer"
                            @click="()=>useSpell(spell)" @mouseover="() => onSpellHover(spell)"
                            @mouseleave="() => onSpellLeave(spell)" @mousedown="holdClickHoverOn"
                            @mouseup="holdClickHoverOff" @touchstart="holdClickHoverOn" @touchend="holdClickHoverOff"
                            @touchcancel="holdClickHoverOff">
                            <img v-if="spell.icon" :src="'img/spells/'+spell.icon+'.jpg'" />
                            <div v-if="spell.icon && (spell.mana>player.mana || spell.manapersecond>player.mana)"
                                class="notEnoughManaSpell"></div>
                            <div :class="{spellHover:!holdClickHover}"></div>
                            <div :class="{spellHoverClickHold:holdClickHover}"></div>
                            <div v-if="spell.currentCooldown != 0" class="spellCooldownBackground"
                                :style="'background: conic-gradient(transparent '+(360*(1-spell.currentCooldown/spell.cooldown))+'deg, #14161bb0 '+(360*(1-spell.currentCooldown/spell.cooldown))+'deg);'">
                            </div>
                            <div v-if="spell.currentCooldown == 0 && underGCD" class="spellCooldownBackground"
                                :style="'background: conic-gradient(transparent '+(360*(1-remainGCD/globalCooldown))+'deg, #14161bb0 '+(360*(1-remainGCD/globalCooldown))+'deg);'">
                            </div>
                            <div v-if="spell.currentCooldown != 0 && spell.currentCooldown>60000"
                                class="spellCooldownTimer" style="font-size: 20px;">{{
                                Math.ceil(spell.currentCooldown/1000/60) }} m</div>
                            <div v-if="spell.currentCooldown != 0 && spell.currentCooldown<=60000"
                                class="spellCooldownTimer" style="font-size: 25px;">{{
                                Math.ceil(spell.currentCooldown/1000)
                                }}</div>
                        </div>
                    </div>

                    <div class="spellTooltipPosition" v-if="hover">
                        <div class="spellTooltipTitle">
                            {{ hoveredSpell.name }}
                        </div>
                        <div class="spellTooltipManaCost" v-if="hoveredSpell.mana>0 && !hoveredSpell.channeled">
                            {{ hoveredSpell.mana }}% Mana
                        </div>
                        <div class="spellTooltipManaCost" v-if="hoveredSpell.manapersecond>0 && hoveredSpell.channeled">
                            {{ Number((hoveredSpell.manapersecond * (1 + this.player.haste / 100)).toFixed(2)) }}% Mana
                            per
                            second
                        </div>
                        <div class="spellTooltipCastTime">
                            <template v-if="hoveredSpell.incantTime>1">{{
                                Number((hoveredSpell.incantTime/1000).toFixed(2))
                                }}
                                sec cast</template>
                            <template
                                v-else-if="hoveredSpell.incantTime==0 && !hoveredSpell.channeled">Instant</template>
                            <template v-else-if="hoveredSpell.channeled">Channeled</template>
                            <div class="spellTooltipCooldown" v-if="hoveredSpell.cooldown>0">
                                {{ Number((hoveredSpell.cooldown/1000/60).toFixed(1)) }} min cooldown
                            </div>
                        </div>
                        <div class="spellTooltipDesc">
                            <template v-if="!hoveredSpell.channeled">{{ replaceTooltipString(hoveredSpell.tooltip,
                                hoveredSpell.effectAmount) }}</template>
                            <template v-else>{{ replaceTooltipString(hoveredSpell.tooltip,
                                hoveredSpell.channelEffectAmount,
                                hoveredSpell.channelTime) }}</template>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function rand(min, max) { // min and max included 
            return Math.floor(Math.random() * (max - min + 1) + min);
        }

        Array.prototype.removeIf = function (callback) {
            var i = 0;
            while (i < this.length) {
                if (callback(this[i], i)) {
                    this.splice(i, 1);
                }
                else {
                    ++i;
                }
            }
        }

        var app = new Vue({
            el: '#app',
            data: {
                choseClass: false,
                selectedClazz: null,
                choseSpec: false,
                choseRace: false,
                choseStats: false,
                keyPressed: false,
                toggleBackgroundImage: false,
                toggleBackgroundImageVignette: true,
                backgroundImage: null,
                backgroundBlurValue: 20,
                defaultBackgroundColor: '#' + 242426,
                backgroundColor: '#' + 242426,
                globalIncrement: 0,
                selected: -1,
                currentCast: -1,
                currentCastAnim: -1,
                currentCastName: null,
                currentCastTime: null,
                currentCastHeal: null,
                spellProgressBar: 0,
                castbarBackground: 0,
                incantTotalTime: 0,
                breakIncantation: 0,
                breakChanneling: 0,
                castTimeRemaining: 0,
                channelTicksInterval: null,
                isPlayerCasting: false,
                isPlayerChanneling: false,
                hover: false,
                hoveredSpell: null,
                holdClickHover: false,
                spellInQueue: false,
                manaRegen: 0.8/60, // (100 * 0.008)
                globalCooldown: 1500,
                remainGCD: null,
                underGCD: false,
                spellQueueDelay: 400,
                spellchannelTicks: 0,
                precedentTargetId: null,
                allyTank: 0,
                allyHealer: 0,
                allyDps: 0,
                allies: [
                ],
                player: {
                    clazz: null,
                    maxHp: 35000,
                    hp: 20000,
                    hpShield: 0,
                    mana: 100,
                    maxSpecialPower: 0,
                    specialPower: 0,
                    id: -1,
                    spellPower: 1000,
                    haste: 0,
                    versatility: 0,
                    criticalStrike: 0,
                    mastery: 0,
                    damageReduction: 0,
                    incomingHeal: false,
                    activeEffects: [],
                    activeShields: [],
                    addMana: function (value) {
                        this.mana = Math.max(0, Math.min(100, this.mana + value))
                    },
                    addHp: function (value) {
                        if (value < 0) {
                            value *= (1 - this.damageReduction / 100)
                            value = Math.round(value)

                            let damageLeft = Math.abs(value)
                            for (const shield of this.activeShields.slice().reverse()) {
                                if (shield.value > damageLeft) {
                                    shield.value -= damageLeft
                                    damageLeft = 0
                                    break
                                }

                                if (shield.value <= damageLeft) {
                                    damageLeft -= shield.value
                                    shield.value = 0
                                }

                                if (shield.value == 0) {
                                    this.activeShields.removeIf((x) => x.id == shield.id)
                                    this.activeEffects.removeIf((x) => x.id == shield.id)
                                }
                            }

                            if (damageLeft != 0) {
                                this.hp = Math.max(0, Math.min(this.maxHp, this.hp - damageLeft))
                            }
                        } else {
                            this.hp = Math.max(0, Math.min(this.maxHp, this.hp + value))
                        }
                    },
                    addHpPercent: function (value) {
                        let finalValue = Math.round(this.maxHp * value / 100)
                        if (finalValue < 0) {

                            let damageLeft = Math.abs(finalValue)
                            for (const shield of this.activeShields.slice().reverse()) {
                                if (shield.value > damageLeft) {
                                    shield.value -= damageLeft
                                    damageLeft = 0
                                    break
                                }

                                if (shield.value <= damageLeft) {
                                    damageLeft -= shield.value
                                    shield.value = 0
                                }

                                if (shield.value == 0) {
                                    this.activeShields.removeIf((x) => x.id == shield.id)
                                    this.activeEffects.removeIf((x) => x.id == shield.id)
                                }
                            }

                            if (damageLeft != 0) {
                                this.hp = Math.max(0, Math.min(this.maxHp, this.hp - damageLeft))
                            }
                        } else {
                            this.hp = Math.max(0, Math.min(this.maxHp, this.hp + finalValue))
                        }
                    },
                    addShield: function (shield) {
                        this.activeShields.push(shield)
                    },
                    addReduction: function (value) {
                        this.damageReduction += value
                    },
                    removeDebuff: function (value) {
                        for (const effect of this.activeEffects) {
                            if (!effect.buff && effect.type == value) {
                                effect.duration = 0
                            }
                        }
                    },
                    generateSP: function (value) {
                        if (this.maxSpecialPower < this.specialPower + value) {
                            this.specialPower = this.maxSpecialPower
                        } else {
                            this.specialPower += value
                        }
                    },
                },
                spells: [
                ],
                classes: {
                    Druid: {
                        name: 'Druid',
                        color: '#FF7C0A',
                        spells: [
                            {
                                id: 3,
                                name: "Rebirth",
                                mana: 0,
                                manapersecond: 0,
                                baseEffectAmount: 0,
                                effectAmount: 0,
                                tooltip: "Returns the spirit to the body, restoring a dead target to life with 100% health. Castable in combat.",
                                icon: "spell_nature_reincarnation",
                                baseIncantTime: 2000,
                                incantTime: 2000,
                                baseChannelTime: 0,
                                channelTime: 0,
                                channelTicks: 0,
                                channelEffectAmount: 0,
                                channeled: false,
                                cooldown: 600000,
                                currentCooldown: 0,
                                affectGCD: true,
                                deadTargetEffect: 1,
                                key: 51,
                                reactToStatus: null,
                                applyStatus: null,
                                applyStatus2: null,
                                use: function (game, state) {
                                    game.findEntityById(state.selectedEntityId).addHpPercent(100)
                                },
                            },
                            {
                                id: 8,
                                name: "Lifebloom",
                                mana: 1.5,
                                manapersecond: 0,
                                baseEffectAmount: 1.95,
                                effectAmount: 1.95,
                                tooltip: "Heals the target for #spellpower over 15 sec. When Lifebloom expires or is dispelled, the target is instantly healed for (115% of Spell power). May be active on one target at a time.",
                                icon: "inv_misc_herb_felblossom",
                                baseIncantTime: 0,
                                incantTime: 0,
                                baseChannelTime: 0,
                                channelTime: 0,
                                channelTicks: 0,
                                channelEffectAmount: 0,
                                channeled: false,
                                cooldown: 0,
                                currentCooldown: 0,
                                affectGCD: true,
                                deadTargetEffect: 0,
                                key: 49,
                                reactToStatus: null,
                                applyStatus: 5,
                                applyStatus2: null,
                                use: function (game, state) {
                                },
                            },
                        ],
                    },
                    Monk: {
                        name: 'Monk',
                        color: '#00FF98',
                        spells: [
                            {
                                id: 4,
                                name: "Soothing Mist",
                                mana: 0,
                                manapersecond: 0.4,
                                baseEffectAmount: 0.55,
                                effectAmount: 0.55,
                                tooltip: "Heals the target for #spellpower over #channeltime sec.  While channeling, Enveloping Mist and Vivify may be cast instantly on the target.",
                                icon: "ability_monk_soothingmists",
                                baseIncantTime: 0,
                                incantTime: 0,
                                baseChannelTime: 8000,
                                channelTime: 8000,
                                channelTicks: 8,
                                channelEffectAmount: 4.4,
                                channeled: true,
                                cooldown: 0,
                                currentCooldown: 0,
                                affectGCD: true,
                                deadTargetEffect: 0,
                                key: 49,
                                reactToStatus: null,
                                applyStatus: 4,
                                applyStatus2: null,
                                use: function (game, state) {
                                    game.findEntityById(state.selectedEntityId).addHp(this.effectAmount)
                                },
                            },
                        ],
                    },
                    Paladin: {
                        name: 'Paladin',
                        color: '#F48CBA',
                        specialPower: true,
                        spells: [
                            {
                                id: 7,
                                name: "Flash of Light",
                                mana: 4, // Idk if it's the real value, I calculated it myself on a trial character
                                manapersecond: 0,
                                useSP: false, // if the spell use SP as cost
                                spCost: null, // number of SP used by the spell
                                baseEffectAmount: 1.68,
                                effectAmount: 1.68,
                                tooltip: "Expends a large amount of mana to quickly heal a friendly target for #spellpower.",
                                icon: "spell_holy_flashheal",
                                baseIncantTime: 1500,
                                incantTime: 1500,
                                baseChannelTime: 0,
                                channelTime: 0,
                                channelTicks: 0,
                                channelEffectAmount: 0,
                                channeled: false,
                                cooldown: 0,
                                currentCooldown: 0,
                                affectGCD: true,
                                deadTargetEffect: 0,
                                key: 49,
                                reactToStatus: null,
                                applyStatus: null,
                                applyStatus2: null,
                                use: function (game, state) {
                                    game.findEntityById(state.selectedEntityId).addHp(this.effectAmount)
                                    game.player.generateSP(1) // generate one point of special power (SP)
                                },
                            },
                            {
                                id: 10,
                                name: "Light of Dawn",
                                mana: 0, // Idk if it's the real value, I calculated it myself on a trial character
                                manapersecond: 0,
                                useSP: true, // if the spell use SP as cost
                                spCost: 3, // number of SP used by the spell
                                baseEffectAmount: 1.05,
                                effectAmount: 1.05,
                                tooltip: "Unleashes a wave of holy energy, healing up to 5 injured allies within a 15 yd frontal cone for #spellpower.",
                                icon: "spell_paladin_lightofdawn",
                                baseIncantTime: 0,
                                incantTime: 0,
                                baseChannelTime: 0,
                                channelTime: 0,
                                channelTicks: 0,
                                channelEffectAmount: 0,
                                channeled: false,
                                cooldown: 0,
                                currentCooldown: 0,
                                affectGCD: true,
                                deadTargetEffect: 0,
                                multiTarget: 4,
                                mostInjured: false, // target the most injured ally.ies
                                effectAmountChange: false,
                                key: 50,
                                reactToStatus: null,
                                applyStatus: null,
                                applyStatus2: null,
                                use: function (game, state) {
                                    game.findEntityById(state.selectedEntityId).addHp(this.effectAmount)
                                },
                            },
                        ],
                    },
                    Priest: {
                        name: 'Priest',
                        color: '#FFFFFF',
                        spells: [ // Name of the class which have the following spells (for the moment there is only one class because the game isn't achieved yet, obviously)
                            {
                                id: 1, // Id of the spell
                                name: "Flash Heal", // Name of the spell
                                mana: 3.6, // Mana used by the spell
                                manapersecond: 0,  // Mana per second use by the spell, used only by channeled spells
                                baseEffectAmount: 2.03, // Base heal amount, this value never change and is used by some functions
                                effectAmount: 2.03, // Same value as spell.use if the spell addHp (used for the heal amount preview)
                                tooltip: "A fast spell that heals an ally for #spellpower.",  // Tooltip of the spell which appear when the spell is hover
                                icon: "spell_holy_flashheal", // Icon of the spell
                                baseIncantTime: 1500, // Base spell incant time, this value never change and is used by some functions
                                incantTime: 1500, // Actual incant time, by default it have the same value as the base one but it change depending of the player haste
                                baseChannelTime: 0, // Same as baseIncantTime but for channeled spells
                                channelTime: 0, // Channeling time
                                channelTicks: 0, // How many time between every ticks in channeling to trigger the effect
                                channelEffectAmount: 0, // total heal amount from the channeling
                                channeled: false, // false : the spell is a normal one (castable), true : the spell is a channeled one
                                cooldown: 0, // The cooldown applied after the cast of the spell
                                currentCooldown: 0, // Current cooldown, this value change if the spell have a cooldown, after it've been used
                                affectGCD: true, // If using this spell affect the GCD
                                deadTargetEffect: 0, // 0 = false; 1 = true ==> if the spell is only usable on dead allies (only for battle rez, i think c:)
                                key: 49, // Keybinding, should change in several updates, when I'll added the key on the spellbar, not on the spell itself
                                reactToStatus: null, // Trigger an effect if the spell is cast on an entity who have the following effect id
                                applyStatus: null, // The status ID (buff or debuff) applied after the spell
                                applyStatus2: null, // Same as applyStatus but if the spell trigger a supplement status
                                use: function (game, state) {  // Function of the spell when it is used
                                    game.findEntityById(state.selectedEntityId).addHp(this.effectAmount) // Here, the spell adds hp to the target
                                },
                            },
                            {
                                id: 2,
                                name: "Heal",
                                mana: 2.4,
                                manapersecond: 0,
                                baseEffectAmount: 2.95,
                                effectAmount: 2.95,
                                tooltip: "An efficient spell that heals an ally for #spellpower.",
                                icon: "spell_holy_greaterheal",
                                baseIncantTime: 2500,
                                incantTime: 2500,
                                baseChannelTime: 0,
                                channelTime: 0,
                                channelTicks: 0,
                                channelEffectAmount: 0,
                                channeled: false,
                                cooldown: 0,
                                currentCooldown: 0,
                                affectGCD: true,
                                deadTargetEffect: 0,
                                key: 50,
                                reactToStatus: null,
                                applyStatus: null,
                                applyStatus2: null,
                                use: function (game, state) {
                                    game.findEntityById(state.selectedEntityId).addHp(this.effectAmount)
                                },
                            },
                            {
                                id: 5,
                                name: "Power Word: Shield",
                                mana: 3.1,
                                manapersecond: 0,
                                baseEffectAmount: 1.65,
                                effectAmount: 1.65,
                                tooltip: "Shields an ally for 15 sec, absorbing #spellpower damage.  You cannot shield the target again for 7.5 sec.",
                                icon: "spell_holy_powerwordshield",
                                baseIncantTime: 0,
                                incantTime: 0,
                                baseChannelTime: 0,
                                channelTime: 0,
                                channelTicks: 0,
                                channelEffectAmount: 0,
                                channeled: false,
                                cooldown: 0,
                                currentCooldown: 0,
                                affectGCD: true,
                                deadTargetEffect: 0,
                                key: 51,
                                reactToStatus: 2,
                                applyStatus: 1,
                                applyStatus2: 2,
                                use: function (game, state) {
                                },
                            },
                            {
                                id: 6,
                                name: "Renew",
                                mana: 1.8,
                                manapersecond: 0,
                                baseEffectAmount: 1.6,
                                effectAmount: 1.6,
                                tooltip: "Fill the target with faith in the light, healing for #spellpower over 15 sec.",
                                icon: "spell_holy_renew",
                                baseIncantTime: 0,
                                incantTime: 0,
                                baseChannelTime: 0,
                                channelTime: 0,
                                channelTicks: 0,
                                channelEffectAmount: 0,
                                channeled: false,
                                cooldown: 0,
                                currentCooldown: 0,
                                affectGCD: true,
                                deadTargetEffect: 0,
                                key: 52,
                                reactToStatus: null,
                                applyStatus: 3,
                                applyStatus2: null,
                                use: function (game, state) {
                                },
                            },
                        ],
                    },
                    Shaman: {
                        name: 'Shaman',
                        color: '#0070DD',
                        spells: [
                            {
                                id: 9,
                                name: "Chain Heal",
                                mana: 6,
                                manapersecond: 0,
                                baseEffectAmount: 2.1,
                                effectAmount: 2.1,
                                tooltip: "Heals the friendly target for #spellpower, then jumps to heal the 2 most injured nearby allies. Healing is reduced by 30% with each jump.",
                                icon: "spell_nature_healingwavegreater",
                                baseIncantTime: 2500,
                                incantTime: 2500,
                                baseChannelTime: 0,
                                channelTime: 0,
                                channelTicks: 0,
                                channelEffectAmount: 0,
                                channeled: false,
                                cooldown: 0,
                                currentCooldown: 0,
                                affectGCD: true,
                                deadTargetEffect: 0,
                                multiTarget: 3, // number of additional targets
                                mostInjured: true, // target the most injured ally.ies
                                effectAmountChange: true,
                                key: 49,
                                reactToStatus: null,
                                applyStatus: null,
                                applyStatus2: null,
                                use: function (game, state) { // one use per ally
                                    game.findEntityById(state.selectedEntityId).addHp(this.effectAmount)
                                },
                                use1: function (game, state) { 
                                    game.findEntityById(state.selectedEntityId).addHp(this.effectAmount*Math.pow(0.7, 1))
                                },
                                use2: function (game, state) {
                                    game.findEntityById(state.selectedEntityId).addHp(this.effectAmount*Math.pow(0.7, 2))
                                },
                                use3: function (game, state) {
                                    game.findEntityById(state.selectedEntityId).addHp(this.effectAmount*Math.pow(0.7, 3))
                                },
                            },
                        ],
                    },
                },
                statusEffects: [ // not final, still thinking about how I can do this simply without reworking all my code
                    {
                        id: 1, // id of the status effect
                        name: "Power Word: Shield", // its name
                        buff: true, // false if it's a debuff, used to change the border color
                        type: "magic", // curse, disease, magic, poison --> for dispelling
                        limitedToOneTarget: false, // if the effect is limited to one target
                        fromChannelingSpell: false, // if it's a buff given by a channeled spell
                        baseEffect: 1.65,
                        effect: 1.65, // cast one time in a buff where ticks=0, else it is cast at every ticks -- applyEffect
                        effectAffectedByStats: true,
                        baseEffect2: null,
                        effect2: null, // cast one time at the start of the buff, even in an effect with ticks>0 -- applyEffect2
                        effect2AffectedByStats: false,
                        haveEndEffect: false, // effect cast one time at the end of the buff -- applyEndEffect
                        baseEndEffectValue: null,
                        endEffectValue: null,
                        endEffectAffectedByStats: false,
                        baseDuration: 15000, // base duration of the statusEffect
                        maxDuration: 15000, // max value of the duration, only affect by stats
                        duration: 15000, // duration
                        durationAffectedByStats: false,
                        ticks: null, // number of times the effect is triggered. Null if the buff don't repeat the effect
                        beingRenewed: false, // Always false, used to renewed the effect in the function
                        break: false, // Always false, used to break the loop
                        tooltip: "test",
                        icon: "spell_holy_powerwordshield",
                        applyEffect: function (game, state) {
                            game.findEntityById(state.selectedEntityId).addShield({
                                id: this.id,
                                value: this.effect,
                            })
                        },
                    },
                    {
                        id: 2,
                        name: "Weakened Soul",
                        buff: false,
                        type: null,
                        limitedToOneTarget: false,
                        fromChannelingSpell: false,
                        baseEffect: null,
                        effect: null,
                        effectAffectedByStats: false,
                        baseEffect2: null,
                        effect2: null,
                        effect2AffectedByStats: false,
                        haveEndEffect: false,
                        baseEndEffectValue: null,
                        endEffectValue: null,
                        endEffectAffectedByStats: false,
                        baseDuration: 7500,
                        maxDuration: 7500,
                        duration: 7500,
                        durationAffectedByStats: false,
                        ticks: null,
                        beingRenewed: false,
                        break: false,
                        tooltip: "test",
                        icon: "spell_holy_ashestoashes",
                    },
                    {
                        id: 3,
                        name: "Renew",
                        buff: true,
                        type: "magic",
                        limitedToOneTarget: false,
                        fromChannelingSpell: false,
                        baseEffect: 0.32,
                        effect: 0.32,
                        effectAffectedByStats: true,
                        baseEffect2: null,
                        effect2: null,
                        effect2AffectedByStats: false,
                        haveEndEffect: false,
                        baseEndEffectValue: null,
                        endEffectValue: null,
                        endEffectAffectedByStats: false,
                        baseDuration: 15000,
                        maxDuration: 15000,
                        duration: 15000,
                        durationAffectedByStats: false,
                        ticks: 5,
                        beingRenewed: false,
                        break: false,
                        tooltip: "test",
                        icon: "spell_holy_renew",
                        applyEffect: function (game, state) {
                            game.findEntityById(state.selectedEntityId).addHp(this.effect)
                        },
                    },
                    {
                        id: 4,
                        name: "Soothing Mist",
                        buff: true,
                        type: null,
                        limitedToOneTarget: false,
                        fromChannelingSpell: true,
                        baseEffect: 0.55,
                        effect: 0.55,
                        effectAffectedByStats: true,
                        baseEffect2: null,
                        effect2: null,
                        effect2AffectedByStats: false,
                        haveEndEffect: false,
                        baseEndEffectValue: null,
                        endEffectValue: null,
                        endEffectAffectedByStats: false,
                        baseDuration: 8000,
                        maxDuration: 8000,
                        duration: 8000,
                        durationAffectedByStats: true,
                        ticks: null,
                        beingRenewed: false,
                        break: false,
                        tooltip: "test",
                        icon: "ability_monk_soothingmists",
                        applyEffect: function (game, state) { },
                    },
                    {
                        id: 5,
                        name: "Lifebloom",
                        buff: true,
                        type: null,
                        limitedToOneTarget: true,
                        fromChannelingSpell: false,
                        baseEffect: 0.13,
                        effect: 0.13,
                        effectAffectedByStats: true,
                        baseEffect2: null,
                        effect2: null,
                        effect2AffectedByStats: false,
                        haveEndEffect: true,
                        baseEndEffectValue: 1.15,
                        endEffectValue: 1.15,
                        endEffectAffectedByStats: true,
                        baseDuration: 15000,
                        maxDuration: 15000,
                        duration: 15000,
                        durationAffectedByStats: false,
                        ticks: 15,
                        beingRenewed: false,
                        break: false,
                        tooltip: "test",
                        icon: "inv_misc_herb_felblossom",
                        applyEffect: function (game, state) {
                            game.findEntityById(state.selectedEntityId).addHp(this.effect)
                        },
                        applyEndEffect: function (game, state) {
                            game.findEntityById(state.selectedEntityId).addHp(this.endEffectValue)
                        }
                    },
                ],
            },

            computed: {
                selectedEntity() {
                    if (this.selected == this.player.id) {
                        return this.player;
                    } else {
                        return this.allies[this.selected];
                    }
                },

                currentCastLabel() {
                    if (this.currentCast != -1) {
                        return this.currentCastName //+ " " + this.currentCastTime;
                    }
                },

            },

            methods: {
                onSpellHover(spell) {
                    if (!spell.name) {
                        return;
                    }

                    this.hover = true;
                    this.hoveredSpell = spell;
                },

                onSpellLeave(spell) {
                    if (this.hoveredSpell?.name == spell.name) {
                        this.hover = false;
                        this.hoveredSpell = null;
                        this.holdClickHover = false;
                    }
                },

                holdClickHoverOn() {
                    if (this.hoveredSpell) {
                        this.holdClickHover = true
                    }
                },

                holdClickHoverOff() {
                    this.holdClickHover = false
                },

                replaceTooltipString(source, spellPowerValue, channelTimeValue) {
                    source = source.replace('#spellpower', Number((spellPowerValue).toFixed(0)))
                    source = source.replace('#channeltime', Number((channelTimeValue / 1000).toFixed(2)))
                    return source
                },

                breakUseSpell() {
                    clearTimeout(this.currentCast)
                    this.currentCastAnim = -1
                    this.currentCast = -1
                    this.spellProgressBar = 0
                    this.castbarBackground = 0
                    this.currentCastName = null
                    this.isPlayerCasting = false
                    this.isPlayerChanneling = false
                    this.castTimeRemaining = 0
                    this.currentCastHeal = null
                },

                breakSpellAnimation() { // less instable than breakUseSpell
                    clearTimeout(this.currentCast)
                    this.currentCastAnim = -1
                    this.currentCastHeal = null
                    this.castbarBackground = 0
                    this.castTimeRemaining = 0
                    this.spellProgressBar = 0
                },

                addAlly(number, desiredRole) {
                    for (let i = 0; i < number; i++) {
                        this.allies.push({
                            maxHp: 20000,
                            hp: Math.random() * 20000,
                            hpShield: 0,
                            role: desiredRole, //["tank", "healer", "dps"][rand(0, 2)],
                            getProperRole: false,
                            id: ++this.globalIncrement,
                            damageReduction: 0,
                            incomingHeal: false,
                            activeEffects: [],
                            activeShields: [],
                            addHp: function (value) {
                                if (value < 0) {
                                    value *= (1 - this.damageReduction / 100)
                                    value = Math.round(value)

                                    let damageLeft = Math.abs(value)
                                    for (const shield of this.activeShields.slice().reverse()) {
                                        if (shield.value > damageLeft) {
                                            shield.value -= damageLeft
                                            damageLeft = 0
                                            break
                                        }

                                        if (shield.value <= damageLeft) {
                                            damageLeft -= shield.value
                                            shield.value = 0
                                        }

                                        if (shield.value == 0) {
                                            this.activeShields.removeIf((x) => x.id == shield.id)
                                            this.activeEffects.removeIf((x) => x.id == shield.id)
                                        }
                                    }

                                    if (damageLeft != 0) {
                                        this.hp = Math.max(0, Math.min(this.maxHp, this.hp - damageLeft))
                                    }
                                } else {
                                    this.hp = Math.max(0, Math.min(this.maxHp, this.hp + value))
                                }
                            },
                            addHpPercent: function (value) {
                                let finalValue = Math.round(this.maxHp * value / 100)
                                if (finalValue < 0) {

                                    let damageLeft = Math.abs(finalValue)
                                    for (const shield of this.activeShields.slice().reverse()) {
                                        if (shield.value > damageLeft) {
                                            shield.value -= damageLeft
                                            damageLeft = 0
                                            break
                                        }

                                        if (shield.value <= damageLeft) {
                                            damageLeft -= shield.value
                                            shield.value = 0
                                        }

                                        if (shield.value == 0) {
                                            this.activeShields.removeIf((x) => x.id == shield.id)
                                            this.activeEffects.removeIf((x) => x.id == shield.id)
                                        }
                                    }

                                    if (damageLeft != 0) {
                                        this.hp = Math.max(0, Math.min(this.maxHp, this.hp - damageLeft))
                                    }
                                } else {
                                    this.hp = Math.max(0, Math.min(this.maxHp, this.hp + finalValue))
                                }
                            },
                            addShield: function (shield) {
                                this.activeShields.push(shield)
                            },
                            addReduction: function (value) {
                                this.damageReduction += value
                            },
                            removeDebuff: function (value) {
                                for (const effect of this.activeEffects) {
                                    if (!effect.buff && effect.type == value) {
                                        effect.duration = 0
                                    }
                                }
                            },
                        })
                    }
                },

                removeLastAlly() {
                    this.allies.pop()
                },

                removeAllAllies() {
                    this.allies = []
                },

                changeAllyHpByRole() {
                    for (const ally of this.allies) {
                        if (!ally.getProperRole) {
                            if (ally.role == "tank") {
                                ally.maxHp = 60000
                                ally.hp = 60000
                                ally.damageReduction = 10
                            } else {
                                ally.maxHp = rand(3000, 3950) * 10
                                ally.hp = rand(1, ally.maxHp) //toDo : set to ally.maxHp -- math random for tests
                            }
                            ally.getProperRole = true
                        }
                    }
                },

                cooldownSubstract(spell) {
                    setTimeout(() => {
                        spell.currentCooldown -= 1000 / 20
                        if (spell.currentCooldown > 0) {
                            this.cooldownSubstract(spell)
                        }
                    }, 1000 / 20)
                },

                globalCooldownFunction() {
                    this.underGCD = true
                    this.remainGCD = this.globalCooldown
                    const darkmoon = () => {
                        this.remainGCD -= 1000 / 60
                        if (Math.round(this.remainGCD) > 0) {
                            setTimeout(darkmoon, 1000 / 60);
                        } else {
                            this.remainGCD = null
                            this.underGCD = false
                        }
                    }
                    setTimeout(darkmoon, 1000 / 60);
                },

                findEntityById(id) {
                    if (id == this.player.id) {
                        return this.player
                    } else {
                        for (const ally of this.allies) {
                            if (ally.id == id) {
                                return ally;
                            }
                        }

                        return null;
                    }
                },

                findStatusEffectById(id) {
                    for (const statusEffect of this.statusEffects) {
                        if (statusEffect.id == id) {
                            return statusEffect;
                        }
                    }

                    return null;
                },

                spellReactionToEffect(target, spell) {
                    for (const targetEffect of target.activeEffects) {
                        if (targetEffect.id == spell.reactToStatus) {
                            return true
                        }
                    }
                    return false
                },

                getEntityTotalShield(entity) {
                    let shieldSum = 0
                    for (const shield of entity.activeShields) {
                        shieldSum += shield.value
                    }
                    entity.hpShield = shieldSum
                },

                formatHpLabel(ally) {
                    if (ally.hp <= 0) {
                        return "dead"
                    }

                    return Math.ceil(ally.hp / ally.maxHp * 100) + '%'
                },

                formatlittleHpLabel(ally) { // toggle option later, show the real hp
                    if (ally.hp <= 0) { // can also disable this if to show "0 / maxHp" which is pretty good looking
                        return ""
                    }

                    return Math.ceil(ally.hp) + " / " + Math.ceil(ally.maxHp)
                },

                addSpell() {
                    this.spells.push({})
                },

                debugSpawnAlly() {
                    this.addAlly(1, ['tank', 'healer', 'dps'][rand(0, 2)])
                    this.changeAllyHpByRole()
                },

                playerSetMaxMana() {
                    this.player.mana = 100
                },

                playerSetMinMana() {
                    this.player.mana = 0
                },

                killAllAllies(){
                    for (const ally of this.allies) { ally.addHpPercent(-100) }
                },

                reviveAllAllies(){
                    for (const ally of this.allies) { ally.addHpPercent(100) }
                },

                channeledSpellBreakBuff(target, spell) {
                    target.activeEffects.removeIf((x) => x.id == spell.applyStatus)
                    target.activeShields.removeIf((x) => x.id == spell.applyStatus)
                    target.activeEffects.removeIf((x) => x.id == spell.applyStatus2)
                    target.activeShields.removeIf((x) => x.id == spell.applyStatus2)
                },

                targetMultipleAllies(spell, initialTargetId) {
                    let allies = [...this.allies, this.player]
                    allies.removeIf((x) => x.id == initialTargetId)
                    allies.removeIf((x) => x.hp <= 0)

                    let toHeal = null

                    if (allies.length <= spell.multiTarget) {
                        toHeal = allies
                    } else {
                        if (spell.mostInjured) {
                            allies.sort((a, b) => (a.hp/a.maxHp) - (b.hp/b.maxHp))
                            toHeal = allies.slice(0, spell.multiTarget)
                        } else {
                            toHeal = []
                            for (let i = 0; i < spell.multiTarget; i++) {
                                toHeal.push(allies.splice(rand(0, allies.length - 1), 1)[0])
                            }
                        }
                    }
                    
                    if (spell.effectAmountChange) {
                        for (let i = 0; i < spell.multiTarget; i++) {
                            let ally = toHeal.shift()
                            if (i==0) {
                                spell.use1(this, { selectedEntityId: ally.id })
                            }
                            if (i==1) {
                                spell.use2(this, { selectedEntityId: ally.id })
                            }
                            if (i==2) {
                                spell.use3(this, { selectedEntityId: ally.id })
                            }
                        }
                    } else {
                        toHeal.forEach((ally) => spell.use(this, { selectedEntityId: ally.id }))
                    }
                },

                statsCalculation() { // toDo : do the same for effects
                    for (const spell of this.spells) {
                        //haste
                        spell.incantTime = spell.baseIncantTime / (1 + this.player.haste / 100)
                        spell.channelTime = spell.baseChannelTime / (1 + this.player.haste / 100)
                        if (this.player.clazz != "Monk") {
                            this.globalCooldown = Math.max(750, Math.round(1500 / (1 + this.player.haste / 100))) // 1500 for baseGCD, if it cause problems later ==> create a var baseGCD in data
                        } else {
                            this.globalCooldown = Math.max(750, Math.round(1000 / (1 + this.player.haste / 100))) // 1500 for baseGCD, if it cause problems later ==> create a var baseGCD in data
                        }
                        //spellpower & versatility
                        spell.effectAmount = Math.round(spell.baseEffectAmount * this.player.spellPower * (1 + this.player.versatility / 100))
                        if (spell.channeled) {
                            spell.channelEffectAmount = Math.round(spell.baseEffectAmount * this.player.spellPower * (1 + this.player.versatility / 100)) * spell.channelTicks
                        }
                    }
                    for (const effect of this.statusEffects) {
                        //haste
                        if (effect.durationAffectedByStats) {
                            effect.maxDuration = effect.baseDuration / (1 + this.player.haste / 100)
                            effect.duration = effect.baseDuration / (1 + this.player.haste / 100)
                        }
                        //spellpower & versatility
                        if (effect.effectAffectedByStats) {
                            effect.effect = Math.round(effect.baseEffect * this.player.spellPower * (1 + this.player.versatility / 100))
                        }
                        if (effect.effect2AffectedByStats) {
                            effect.effect2 = Math.round(effect.baseEffect2 * this.player.spellPower * (1 + this.player.versatility / 100))
                        }
                        if (effect.endEffectAffectedByStats) {
                            effect.endEffectValue = Math.round(effect.baseEndEffectValue * this.player.spellPower * (1 + this.player.versatility / 100))
                        }
                    }
                },

                selectClass(clazz) {
                    this.spells.length = 0;

                    for (const spell of this.classes[clazz].spells) {
                        this.spells.push({
                            ...spell,
                        });
                    }

                    const totalspells = 24 - this.spells.length
                    for (let i = 0; i < totalspells; i++) {
                        this.addSpell()
                    }
                    if (this.classes[clazz].specialPower) {
                        this.player.maxSpecialPower = 5 // only paladin can use special power to heal, so I set it to 5
                        this.player.specialPower = 0
                    } else {
                        this.player.maxSpecialPower = 0
                        this.player.specialPower = 0
                    }
                    this.player.clazz = clazz
                    this.statsCalculation()
                },

                useSpell(spell) {
                    const selectedEntityId = this.selectedEntity.id
                    if (this.spellReactionToEffect(this.findEntityById(selectedEntityId), spell)) { // if spell react to a buff/debuff
                        if (spell.id == 5) { // Power Word: Shield
                            return
                        }
                    }
                    if (spell.currentCooldown <= 0 && this.player.mana - spell.mana >= 0 && this.player.mana - spell.manapersecond >= 0) {
                        if (!spell.channeled) {
                            if (spell.useSP && this.player.specialPower < spell.spCost) {
                                return
                            }
                            /*if (spell.incantTime <= 1000) {  // change the spellQueue delay if the spell incant time is lower than 1sec
                                this.spellQueueDelay = spell.incantTime * 0.5
                            }*/
                            this.breakIncantation = 0
                            this.breakChanneling = 0
                            if (this.isPlayerCasting && this.castTimeRemaining > this.spellQueueDelay) { // If it's a different spell, cancel the one currently being cast and cast the new one
                                //this.breakIncantation = 1
                                //this.breakUseSpell()
                                return

                            } else if (this.isPlayerCasting && this.castTimeRemaining <= this.spellQueueDelay && !this.spellInQueue) { // ADD TO QUEUE (chain spell)
                                if (!this.underGCD) {
                                    this.spellInQueue = true
                                    setTimeout(() => {
                                        this.spellInQueue = false
                                        this.useSpell(spell)
                                    }, this.castTimeRemaining)
                                    return
                                } else if (this.underGCD && this.castTimeRemaining <= this.remainGCD + 25) {
                                    this.spellInQueue = true
                                    setTimeout(() => {
                                        this.spellInQueue = false
                                        this.useSpell(spell)
                                    }, this.remainGCD + 25)
                                    return
                                } else { return }
                            }
                            if (!this.underGCD) { // verify if there is the GCD
                                if (this.isPlayerChanneling) { //toDo : when Soothing Mist is channeled the monk can use some spells instantly - 1500 gcd if instacast unlike all others monk abilities
                                    this.breakChanneling = 1
                                    this.isPlayerChanneling = false
                                    this.castTimeRemaining = 0
                                }
                                if (this.spellInQueue) { return }
                                if (spell.incantTime > 0) {
                                    this.currentCastName = spell.name
                                }
                                if (spell.deadTargetEffect == 0) { // Verify if the spell is a healing spell or a battle rez one and then verify if the target can be heal / rez
                                    if (this.findEntityById(selectedEntityId).hp <= 0) { // healing spell (break if target is dead)
                                        this.breakUseSpell()
                                        return
                                    }
                                } else {
                                    if (this.findEntityById(selectedEntityId).hp > 0) { // brez (break if target is alive)
                                        this.breakUseSpell()
                                        return
                                    }
                                }
                                if (spell.affectGCD) {
                                    this.globalCooldownFunction()
                                }
                                if (spell.effectAmount > 0 && spell.baseIncantTime > 0) {
                                    this.currentCastHeal = spell.effectAmount
                                    this.findEntityById(selectedEntityId).incomingHeal = true
                                }
                                this.currentCast = 1
                                this.incantTotalTime = spell.incantTime;
                                this.precedentTargetId = this.findEntityById(selectedEntityId).id
                                let remain = spell.incantTime;
                                let whle = () => {
                                    if (this.breakIncantation == 1) { //break casting
                                        this.breakIncantation = 0
                                        this.findEntityById(selectedEntityId).incomingHeal = false
                                        this.breakSpellAnimation()
                                        return
                                    } else if (this.breakIncantation == 2) { //escape key
                                        this.breakIncantation = 0
                                        this.findEntityById(selectedEntityId).incomingHeal = false
                                        this.breakUseSpell()
                                        return
                                    }
                                    remain -= 1000 / 60
                                    this.castTimeRemaining = remain
                                    this.isPlayerCasting = true
                                    this.castbarBackground = 100
                                    this.currentCastTime = (remain / 1000 / 60)
                                    this.spellProgressBar = 100 - remain / spell.incantTime * 100
                                    if (this.player.mana - spell.mana < 0) {
                                        this.findEntityById(selectedEntityId).incomingHeal = false
                                        this.breakUseSpell()
                                        return
                                    }
                                    if (spell.deadTargetEffect == 0) {
                                        if (this.findEntityById(selectedEntityId).hp <= 0) {
                                            this.findEntityById(selectedEntityId).incomingHeal = false
                                            this.breakUseSpell()
                                            return
                                        }
                                    } /*else if (this.findEntityById(selectedEntityId).hp > 0) {
                                     this.breakUseSpell()
                                     return
                                    } This part is broken, and a lil' bit useless*/

                                    if (Math.round(remain) > 0) {
                                        this.currentCastAnim = setTimeout(whle, 1000 / 60);
                                    } else {
                                        spell.use(this, { selectedEntityId })
                                        if (spell.multiTarget != null && spell.multiTarget > 0) {
                                            this.targetMultipleAllies(spell, this.findEntityById(selectedEntityId).id)
                                        }
                                        if (spell.applyStatus != null) {
                                            this.applyStatusEffect(this.findEntityById(selectedEntityId), this.findStatusEffectById(spell.applyStatus))

                                            if (spell.applyStatus2 != null) {
                                                this.applyStatusEffect(this.findEntityById(selectedEntityId), this.findStatusEffectById(spell.applyStatus2))
                                            }
                                        }
                                        spell.currentCooldown = spell.cooldown
                                        if (spell.useSP) { this.player.specialPower -= spell.spCost }
                                        this.player.addMana(-spell.mana)
                                        this.currentCastAnim = -1
                                        this.currentCast = -1
                                        this.currentCastHeal = null
                                        this.findEntityById(selectedEntityId).incomingHeal = false
                                        this.spellProgressBar = 0
                                        this.castbarBackground = 0
                                        this.currentCastName = null
                                        this.isPlayerCasting = false
                                        this.castTimeRemaining = 0
                                        if (spell.cooldown > 0) {
                                            this.cooldownSubstract(spell)
                                        }
                                        return
                                    }
                                }
                                this.currentCastAnim = setTimeout(whle, 1000 / 60);
                            }
                        }


                        else { // spell is channeled
                            this.breakIncantation = 0
                            this.breakChanneling = 0
                            if (!this.underGCD) {
                                if (spell.name == this.currentCastName) {
                                    this.breakChanneling = 1
                                    if (this.precedentTargetId != this.findEntityById(selectedEntityId).id) {
                                        this.channeledSpellBreakBuff(this.findEntityById(this.precedentTargetId), spell)
                                    }
                                }
                                if (this.isPlayerCasting) { return }
                                this.currentCastName = spell.name
                                if (spell.deadTargetEffect == 0) { // verify if target is dead
                                    if (this.findEntityById(selectedEntityId).hp <= 0) { // healing spell (break if target is dead)
                                        this.breakUseSpell()
                                        return
                                    }
                                }
                                if (spell.affectGCD) {
                                    this.globalCooldownFunction()
                                }
                                this.player.mana -= spell.mana
                                this.currentCast = 1
                                this.incantChannelTime = spell.channelTime;
                                this.channelTicksInterval = spell.channelTime / spell.channelTicks // channeled ticks interval's now here
                                if (spell.applyStatus != null) {
                                    this.applyStatusEffect(this.findEntityById(selectedEntityId), this.findStatusEffectById(spell.applyStatus))

                                    if (spell.applyStatus2 != null) {
                                        this.applyStatusEffect(this.findEntityById(selectedEntityId), this.findStatusEffectById(spell.applyStatus2))
                                    }
                                }
                                this.precedentTargetId = this.findEntityById(selectedEntityId).id
                                let remain = spell.channelTime;
                                let ticks = this.channelTicksInterval
                                let whle = () => {
                                    if (this.breakChanneling == 1) { //break casting
                                        this.breakChanneling = 0
                                        this.breakSpellAnimation()
                                        return
                                    } else if (this.breakChanneling == 2) { //escape key
                                        this.breakChanneling = 0
                                        this.channeledSpellBreakBuff(this.findEntityById(selectedEntityId), spell)
                                        this.breakUseSpell()
                                        return
                                    }
                                    remain -= 1000 / 60
                                    ticks -= 1000 / 60
                                    this.castTimeRemaining = remain
                                    this.spellchannelTicks = spell.channelTicks
                                    this.isPlayerChanneling = true
                                    this.castbarBackground = 100
                                    this.currentCastTime = (remain / 1000 / 60)
                                    this.spellProgressBar = remain / spell.channelTime * 100
                                    if (this.player.mana - spell.manapersecond < 0) {
                                        this.breakUseSpell()
                                        return
                                    }
                                    if (spell.deadTargetEffect == 0) {
                                        if (this.findEntityById(selectedEntityId).hp <= 0) {
                                            this.breakUseSpell()
                                            return
                                        }
                                    }
                                    if (Math.round(ticks) <= 0) { // round to avoid a value like 8.0e-13 =)
                                        spell.use(this, { selectedEntityId })
                                        this.player.addMana(-spell.manapersecond)
                                        ticks = this.channelTicksInterval - 1000 / 60
                                    }
                                    if (Math.round(remain) > 0) {
                                        this.currentCastAnim = setTimeout(whle, 1000 / 60);
                                    } else {
                                        this.channeledSpellBreakBuff(this.findEntityById(selectedEntityId), spell)
                                        spell.currentCooldown = spell.cooldown
                                        this.currentCastAnim = -1
                                        this.currentCast = -1
                                        this.spellProgressBar = 0
                                        this.castbarBackground = 0
                                        this.currentCastName = null
                                        this.isPlayerChanneling = false
                                        this.castTimeRemaining = 0
                                        if (spell.cooldown > 0) {
                                            this.cooldownSubstract(spell)
                                        }
                                        return
                                    }
                                }
                                this.currentCastAnim = setTimeout(whle, 1000 / 60);
                            }
                        }
                    }
                },

                applyStatusEffect(target, effect) {
                    let previous = target.activeEffects.filter((x) => x.id == effect.id)[0] // previous = if the target already have the same effect

                    if (previous != undefined) {
                        previous.beingRenewed = true
                    } else {

                        if (effect.limitedToOneTarget) {
                            if (this.player.activeEffects.filter((x) => x.id == effect.id)[0]) {
                                this.player.activeEffects.filter((x) => x.id == effect.id)[0].break = true
                            } else {
                                for (const ally of this.allies) {
                                    if (ally.activeEffects.filter((x) => x.id == effect.id)[0]) {
                                        ally.activeEffects.filter((x) => x.id == effect.id)[0].break = true
                                    }
                                }
                            }
                        }

                        effect = { ...effect }

                        target.activeEffects.push(effect)

                        effect.duration = effect.maxDuration
                        let selectedEntityId = this.selectedEntity.id

                        if (effect.ticks != null) {
                            let ticksInterval = effect.maxDuration / effect.ticks
                            if (effect.baseEffect2 != null) {
                                effect.applyEffect2(this, { selectedEntityId })
                            }
                            let elune = () => {
                                if (effect.break) {
                                    target.activeEffects.removeIf((x) => x.id == effect.id)
                                    target.activeShields.removeIf((x) => x.id == effect.id)
                                    return
                                }
                                if (effect.beingRenewed) {
                                    target.activeShields.removeIf((x) => x.id == effect.id)
                                    if (effect.baseEffect2 != null) {
                                        effect.applyEffect2(this, { selectedEntityId })
                                    }
                                    effect.duration = effect.maxDuration
                                    ticksInterval = effect.maxDuration / effect.ticks
                                    effect.beingRenewed = false
                                }
                                if (target.hp <= 0) {
                                    effect.duration = 0
                                    target.activeEffects.removeIf((x) => x.id == effect.id)
                                    return
                                }
                                effect.duration -= 1000 / 20
                                ticksInterval -= 1000 / 20
                                if (Math.round(ticksInterval) <= 0) {
                                    effect.applyEffect(this, { selectedEntityId })
                                    ticksInterval = effect.maxDuration / effect.ticks - 1000 / 20
                                }
                                if (Math.round(effect.duration) > 0) {
                                    setTimeout(elune, 1000 / 20)
                                } else {
                                    if (effect.haveEndEffect) {
                                        effect.applyEndEffect(this, { selectedEntityId })
                                    }

                                    target.activeEffects.removeIf((x) => x.id == effect.id)
                                    target.activeShields.removeIf((x) => x.id == effect.id)

                                    return
                                }
                            }
                            setTimeout(elune, 1000 / 20);

                        } else { // no ticks
                            if (effect.baseEffect != null) {
                                effect.applyEffect(this, { selectedEntityId })
                                if (effect.baseEffect2 != null) {
                                    effect.applyEffect2(this, { selectedEntityId })
                                }
                            }
                            let elune = () => {
                                if (effect.break) {
                                    target.activeEffects.removeIf((x) => x.id == effect.id)
                                    target.activeShields.removeIf((x) => x.id == effect.id)
                                    return
                                }
                                if (effect.beingRenewed) {
                                    target.activeShields.removeIf((x) => x.id == effect.id)
                                    if (effect.baseEffect != null) {
                                        effect.applyEffect(this, { selectedEntityId })
                                        if (effect.baseEffect2 != null) {
                                            effect.applyEffect2(this, { selectedEntityId })
                                        }
                                    }
                                    effect.duration = effect.maxDuration
                                    effect.beingRenewed = false
                                }
                                if (effect.fromChannelingSpell) {
                                    if (!this.isPlayerChanneling) {
                                        effect.duration = 0
                                    }
                                }
                                if (target.hp <= 0) { // add the applyEndEffect if it creates problems --> if the effect add damage reduction
                                    effect.duration = 0
                                    target.activeEffects.removeIf((x) => x.id == effect.id)
                                    return
                                }
                                effect.duration -= 1000 / 20
                                if (Math.round(effect.duration) > 0) {
                                    setTimeout(elune, 1000 / 20)
                                } else {
                                    if (effect.haveEndEffect) {
                                        effect.applyEndEffect(this, { selectedEntityId })
                                    }

                                    target.activeEffects.removeIf((x) => x.id == effect.id)
                                    target.activeShields.removeIf((x) => x.id == effect.id)
                                    return
                                }
                            }
                            setTimeout(elune, 1000 / 20);
                        }
                    }
                },
            },

            mounted() {

                document.addEventListener("keydown", (event) => { // Detect if the pressed key is used by a spell, and if so, cast this spell
                    if (this.keyPressed) return;
                    this.keyPressed = true;
                    for (const spell of this.spells) {
                        if (spell.key == event.keyCode) {
                            this.useSpell(spell)
                            break
                        }
                    }


                    if (event.keyCode == 27) { // esc key role --> break cast and if not casting target player
                        if (this.castTimeRemaining > 0) {
                            this.breakIncantation = 2
                            this.breakChanneling = 2
                        } else {
                            this.selected = -1
                        }
                    }
                }, false);

                document.addEventListener("keyup", (event) => {
                    this.keyPressed = false;
                }, false);

                this.statsCalculation()

                this.addAlly(2, "tank");
                this.addAlly(2, "healer");
                this.addAlly(10, "dps");

                this.changeAllyHpByRole()

                let step = 0;

                setInterval(() => {
                    if (step % 60 == 0) {
                        for (const ally of this.allies) {
                            ally.addHp(-ally.maxHp / 100)
                        }
                    }
                    for (const ally of this.allies) {
                        this.getEntityTotalShield(ally)
                    }
                    this.getEntityTotalShield(this.player)
                    this.player.addMana(this.manaRegen)
                    step++
                }, 1000 / 60)
            }

        })
    </script>
</body>

</html>